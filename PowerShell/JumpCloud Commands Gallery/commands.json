[
  {
    "name": "Linux - Disable Local User | v1.0 JCCG",
    "type": "linux",
    "script": "```\n#!/bin/sh\n################################################################################\n# This script will disable the *matched* username patterns in the usersToMatch\n# list variable. For Example:\n# Users on the system: administrator, steve, it-staff\n# export usersToMatch=\"admin it\"\n# both the administrator and it-staff would be disabled\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# Test how this command will run by setting the disable variable to false. When\n# set to false the script will identify users to disable and print out a list\n# without disabling the accounts\n################################################################################\n\n# Settings, set true or false\ndisable=true\n\n# Enter user(s) patterns you want to match against (user admin bobsAccount)\nexport usersToMatch=\"admin it\"\n\n# Do not modify below this line\n################################################################################\n# last item in matched user list\nLAST_ITEM=\"${usersToMatch##* }\"\n# regexMatchregexPattern\nregexPattern=\"\"\n\nfor user in $usersToMatch; do\n    echo \"adding $user to regex pattern\"\n    if [ \"$user\" = \"$LAST_ITEM\" ]; then\n        regexPattern=\"${regexPattern:+${regexPattern}}${user}[^\\s]*\"\n    else\n        regexPattern=\"${regexPattern:+${regexPattern}}${user}[^\\s]*|\"\n    fi\ndone\n\necho \"Searching System for the following users: $usersToMatch\"\necho \"Regex Pattern: $regexPattern\"\n\n# Get usernames on system:\nallUsers=$(cut -d : -f 1 /etc/passwd)\n\nfoundUsers=\"\"\nfor value in $allUsers; do\n    if echo \"$value\" | grep -iqE \"$regexPattern\"; then\n        echo \"found user $value on system\"\n        foundUsers=\"${foundUsers:+${foundUsers}}${value} \"\n    fi\ndone\nloggedInUsers=$(who -u)\nfor user in $foundUsers; do\n    echo \"Disabling $user's login shell...\"\n    # echo \"testing for $user in $loggedInUsers\"\n    if [ $disable = true ]; then\n        if echo \"$loggedInUsers\" | grep -iqE \"$user\"; then\n            echo \"logging $user out of system\"\n            pkill -KILL -u \"${user}\"\n        fi\n        # Expire the user's password\n        sudo usermod --expiredate 1 $user\n        # Remove the user from the login screen\n        printf \"[User]\\nSystemAccount=true\\n\" | sudo tee /var/lib/AccountsService/users/$user\n        sudo systemctl restart accounts-daemon.service\n    fi\ndone\n\n```",
    "link": "https://git.io/JnXsj",
    "description": "This command will disable the local users that match the regex pattern supplied in the 'usersToMatch' list variable. If for example, a system contains the following users:\n\nSteve, Administrator, IT-Admin\n\nAnd the usersToMatch variable is set to (admin it), both the 'Administrator' and 'IT-Admin' Account would be disabled. The Regex pattern searches usernames for partial matches.\n\nRun this script with disable=false to test what accounts would be disabled before running disable=true."
  },
  {
    "name": "Linux - List All Users | v1.0 JCCG",
    "type": "linux",
    "script": "```\nawk -F'[/:]' '{if ($3 >= 1000 && $3 != 65534) print $1}' /etc/passwd\n```",
    "link": "https://git.io/jccg-Linux-ListAllUsers",
    "description": "Lists all users on a Linux system"
  },
  {
    "name": "Linux - List Available Updates | v1.0 JCCG",
    "type": "linux",
    "script": "```\napt-get -u upgrade --assume-no\n```",
    "link": "https://git.io/jccg-Linux-ListavailableUpdates",
    "description": "Shows available updates on a Linux system. The '-assume-no' parameter is used to prevent the installation of any updates."
  },
  {
    "name": "Linux - Pull jcagent.log | v1.0 JCCG",
    "type": "linux",
    "script": "```\ncat /var/log/jcagent.log\n```",
    "link": "https://git.io/jccg-Linux-Pulljcagent.log",
    "description": "Pulls the JC agent log from a Linux system. If the jcagent.log is larger than 1 MB the most recend 1 MB of data from the log will be returned."
  },
  {
    "name": "Linux - Set Agent Log Level to Debug | v1.0 JCCG",
    "type": "linux",
    "script": "```\n#!/bin/bash\n\n# Check for at command, necessary to schedule the command later\ndpkg -l \"at\" > /dev/null 2>&1\nif [ $? = '1' ]; then\n    echo \"at command could not be found, please install 'at' package\"\n    exit 1\nfi\n\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# build the script\ncat <<'EOF' > $scriptFile\n#!/bin/bash\n\n# Set Debug Level | Either \"DEBUG\" or \"TRACE\"\nsetLevel=\"DEBUG\"\n\n# File Locations\nlogLevelFile=\"/opt/jc/loglevel.cache\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Call LogLevel Function to set log level\nif [ ! -f \"$logLevelFile\" ]; then\nprintf DEBUG > $logLevelFile\nfi\n\n# Restart Agent to start logging with new level\nservice jcagent restart\n\n# Remove this script\nrm -- \"$0\"\nEOF\necho \"Setting JumpCloud-Agent Log Level settings\"\nat now + 1 minutes -f $scriptFile\n\nexit 0\n```",
    "link": "https://git.io/JUUdd",
    "description": "This command will set the JumpCloud Agent Log Level to Debug level."
  },
  {
    "name": "Linux - Set Agent Log Level to Debug | v1.0 JCCG",
    "type": "linux",
    "script": "```\n#!/bin/bash\n\n# Check for at command, necessary to schedule the command later\ndpkg -l \"at\" > /dev/null 2>&1\nif [ $? = '1' ]; then\n    echo \"at command could not be found, please install 'at' package\"\n    exit 1\nfi\n\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# build the script\ncat <<'EOF' > $scriptFile\n#!/bin/bash\n\n# Set Debug Level | Either \"DEBUG\" or \"TRACE\"\nsetLevel=\"DEBUG\"\n\n# File Locations\nlogLevelFile=\"/opt/jc/loglevel.cache\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Call LogLevel Function to set log level\nif [ -f \"$logLevelFile\" ]; then\nrm $logLevelFile\nfi\n\n# Restart Agent to start logging with new level\nservice jcagent restart\n\n# Remove this script\nrm -- \"$0\"\nEOF\n\necho \"Setting JumpCloud-Agent Log Level to default settings\"\nat now + 1 minutes -f $scriptFile\n\nexit 0\n```",
    "link": "https://git.io/JUUdF",
    "description": "This command will set the JumpCloud Agent Log Level to Default logging level."
  },
  {
    "name": "Linux - Snap - Install Microsoft VS Code | v1.0 JCCG",
    "type": "linux",
    "script": "```\nsnap install code --classic\n```",
    "link": "https://git.io/JJL0x",
    "description": "Install Microsoft VS Code app with the Snap app manager. To learn more about Snap, visit [SnapCraft's website](https://snapcraft.io/)"
  },
  {
    "name": "Linux - Snap - Install Slack | v1.0 JCCG",
    "type": "linux",
    "script": "```\nsnap install slack --classic\n```",
    "link": "https://git.io/JJL0h",
    "description": "Install Slack app with the Snap app manager. To learn more about Snap, visit [SnapCraft's website](https://snapcraft.io/)"
  },
  {
    "name": "Linux - Install Snap Daemon | v1.0 JCCG",
    "type": "linux",
    "script": "```\napt install snapd\n```",
    "link": "https://git.io/JJLEv",
    "description": "Installs the Snap daemon required to manage applications with Snap. To complete the installation, either logout and login or restart the system. To learn more about Snap, visit [SnapCraft's website](https://snapcraft.io/)"
  },
  {
    "name": "Linux - Snap - Remove Slack | v1.0 JCCG",
    "type": "linux",
    "script": "```\nsnap remove slack\n```",
    "link": "https://git.io/JJLEf",
    "description": "Remove Slack app with the Snap app manager. To learn more about Snap, visit [SnapCraft's website](https://snapcraft.io/)"
  },
  {
    "name": "Mac - Cache Latest MacOS Installer | v1.0 JCCG",
    "type": "mac",
    "script": "```\nsoftwareupdate --fetch-full-installer\n\n# Change the systemGroupID to the system group\nsystemGroupID=\"5e74f14e45886d2939ff2562\"\n\n# Parse the systemKey from the conf file.\nconf=\"$(cat /opt/jc/jcagent.conf)\"\nregex='\\\"systemKey\\\":\\\"[a-zA-Z0-9]{24}\\\"'\n\nif [[ $conf =~ $regex ]]; then\n\tsystemKey=\"${BASH_REMATCH[@]}\"\nfi\n\nregex='[a-zA-Z0-9]{24}'\nif [[ $systemKey =~ $regex ]]; then\n\tsystemID=\"${BASH_REMATCH[@]}\"\nfi\n\n# Get the current time.\nnow=$(date -u \"+%a, %d %h %Y %H:%M:%S GMT\")\n\n# create the string to sign from the request-line and the date\nsignstr=\"POST /api/v2/systemgroups/${systemGroupID}/members HTTP/1.1\\ndate: ${now}\"\n\n# create the signature\nsignature=$(printf \"$signstr\" | openssl dgst -sha256 -sign /opt/jc/client.key | openssl enc -e -a | tr -d '\\n')\n\ncurl -s \\\n\t-X 'POST' \\\n\t-H 'Content-Type: application/json' \\\n\t-H 'Accept: application/json' \\\n\t-H \"Date: ${now}\" \\\n\t-H \"Authorization: Signature keyId=\\\"system/${systemID}\\\",headers=\\\"request-line date\\\",algorithm=\\\"rsa-sha256\\\",signature=\\\"${signature}\\\"\" \\\n\t-d '{\"op\": \"add\",\"type\": \"system\",\"id\": \"'${systemID}'\"}' \\\n\t\"https://console.jumpcloud.com/api/v2/systemgroups/${systemGroupID}/members\"\n\necho \"JumpCloud system: ${systemID} removed from system group: ${systemGroupID}\"\n```",
    "link": "https://git.io/JvSeX",
    "description": "The `softwareupdate --fetch-full-installer` feature was released on macOS Catalina, systems running 10.15 can run `softwareupdate --fetch-full-installer` to download the next version of macOS. The `--fetch-full-installer` option is not included in Mojave and earlier versions of macOS.\n\nThis command invokes the macOS softwareupdate utility. The --fetch-full-installer flag downloads the latest Install macOS installer available from the App Store. The --fetch-full-installer flag contains a sub-flag to specify which version of the latest Install macOS installer to download. For example, `softwareupdate --fetch-full-installer --full-installer-version` 10.15.1 would download the 10.15.1 version of Catalina to the target system. The timeout on this command should be changed to accommodate slower networks. A timeout of 30 mins (or 1800 seconds) should suffice if running on a single system. Change the systemGroupID to a new group ID in your JumpCloud Organization to track systems which have run this command."
  },
  {
    "name": "Mac - Check User for Secure Token | v1.1 JCCG",
    "type": "mac",
    "script": "```\n# Enter the username of the admin you wish to check for a secure token \n# Enter this within the \"\" of SECURETOKEN_ADMIN_USERNAME=\"\"  \n\nSECURETOKEN_ADMIN_USERNAME=\"\"\n\n# Enter a username of an admin user to authorize the sysadminctl command with \n# Enter this within the \"\" of ADMIN_USERNAME=\"\"\n\nADMIN_USERNAME=\"\"\n\n# Enter the password of this admin user\n# Enter this within the \"\" of ADMIN_PASSWORD=\"\"\n\nADMIN_PASSWORD=\"\"\n\n# -------- Do not modify below this line --------\n\nsysadminctl -adminUser $ADMIN_USERNAME -adminPassword $ADMIN_PASSWORD -secureTokenStatus $SECURETOKEN_ADMIN_USERNAME \n\n```",
    "link": "https://git.io/jccg-mac-checkuserforsecuretoken",
    "description": "After importing this command the variables SECURETOKEN_ADMIN_USERNAME=\"\",ADMIN_USERNAME=\"\", and ADMIN_PASSWORD=\"\"  must populated before the command can be run. This command will verify if the user has a secure token enabled.\n\nNote the same admin account can be used for the \nSECURETOKEN_ADMIN_USERNAME=\"\" and the ADMIN_USERNAME=\"\""
  },
  {
    "name": "Mac - Disable Local User | v1.0 JCCG",
    "type": "mac",
    "script": "```\n#!/bin/bash\n################################################################################\n# This script will disable the *matched* username patterns in the usersToMatch\n# list variable. For Example:\n# Users on the system: administrator, steve, it-staff\n# usersToMatch=(admin it)\n# both the administrator and it-staff would be disabled\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# Test how this command will run by setting the disable variable to false. When\n# set to false the script will identify users to disable and print out a list\n# without disabling the accounts\n################################################################################\n\n# Settings, set true or false\ndisable=true\n\n# Enter user(s) patterns you want to match against (user admin bobsAccount)\nusersToMatch=(admin it)\n\n# Do not modify below this line\n################################################################################\n\n# regexMatchregexPattern\nregexPattern=\"\"\n# build regex matching regexPattern\npos=$(( ${#usersToMatch[*]} - 1 ))\nlast=${usersToMatch[$pos]}\nfor user in ${usersToMatch[@]}; do\n    # add to regexPattern\n    if [[ $user == $last ]]; then\n        regexPattern+=\"${user}[^\\s]*\"\n    else\n        regexPattern+=\"${user}[^\\s]*|\"\n    fi\ndone\n\necho \"Searching System for the following users: ${usersToMatch[@]}\"\necho \"Regex Pattern: $regexPattern\"\n\n# Get usernames on system:\nallUsers=$(dscl . list /Users UniqueID | awk '$2>500{print $1}' | grep -v super.admin | grep -v _jumpcloudserviceaccount)\necho \"-------------------------------------------------------------------------\"\necho \"Accounts on the system:\"\necho \"$allUsers\"\necho \"-------------------------------------------------------------------------\"\n\n# Try to find match:\n# Case insensitive search:\n# set nocasematch option\nshopt -s nocasematch\n\nfoundUsers=()\nfor value in ${allUsers[@]}; do\n    if [[ $value =~ $regexPattern ]]; then\n        echo \"matched $value user\"\n        foundUsers+=($value)\n    fi\ndone\n\n# unset nocasematch option\nshopt -u nocasematch\nloggedInUsers=$(who -u)\necho \"The Following users will be disabled: ${foundUsers[@]}\"\nfor user in ${foundUsers[@]}; do\n    echo \"Disabling $user's login shell...\"\n    if [[ $disable = true ]]; then\n        if echo \"$loggedInUsers\" | grep -iqE \"$user\"; then\n            echo \"logging $user out of system\"\n            sudo launchctl bootout user/$(id -u \"${user}\")\n        fi\n        chsh -s /usr/bin/false $user\n    fi\ndone\n```",
    "link": "https://git.io/JnXGT",
    "description": "This command will disable the local users that match the regex pattern supplied in the 'usersToMatch' list variable. If for example, a system contains the following users:\n\nSteve, Administrator, IT-Admin\n\nAnd the usersToMatch variable is set to (admin it), both the 'Administrator' and 'IT-Admin' Account would be disabled. The Regex pattern searches usernames for partial matches.\n\nRun this script with disable=false to test what accounts would be disabled before running disable=true. Set the reboot=true variable to reboot the system, upon next restart the disabled users will be unable to login."
  },
  {
    "name": "Mac - Enroll MDM System in DEP | v1.1 JCCG",
    "type": "mac",
    "script": "```\n#!/bin/bash\n\n# Verify JumpCloud MDM\nverify_jc_mdm (){\n    # Check the system for the following profileIdentifier\n    mdmID=\"com.jumpcloud.mdm\"\n    check=$(profiles -Lv | grep \"name: $4\" -4 | awk -F\": \" '/attribute: profileIdentifier/{print $NF}')\n    if [[ $check == *$mdmID* ]] ; then\n        echo \"ProfileIdentifier: ${mdmID} found on system. MDM Verified\"\n        return\n    else\n        echo \"JumpCloud MDM profile not found on system.\"\n        false\n    fi\n}\n\n# If JumpCLoud MDM is on the system check for DEP Enrollment\nif verify_jc_mdm \"$\":; then\n    depApproveCheck=$(profiles status -type enrollment | grep \"Enrolled via DEP:\" | awk 'NF>1{print $NF}')\n    if [[ $depApproveCheck = \"No\" ]]; then\n        echo \"MDM is not DEP enrolled, enrolling and prompted for User Approval\"\n        # Prompt for DEP Enrollment\n        profiles renew -type enrollment\n        exit 0\n    elif [[ $depApproveCheck = \"Yes)\" ]]; then\n        echo \"MDM is DEP enrolled already\"\n        exit 0\n    fi\nelse\n    exit 1\nfi\n```",
    "link": "https://git.io/JUIqN",
    "description": "**Note** Before using this command, a [JumpCloud tenant must first be configured with Apple Business Manager](https://jumpcloud.com/blog/integrate-apple-business-manager) or Apple School Manager. Devices must then be added to your MDM server by serial number or Apple Order ID through Apple Business Manager or Apple School Manager. Devices with matching Serial numbers will be displayed in a JumpCloud Tenant under \"DEP Devices\"\n\n![Dep Devices](../Files/depDevices.png)\n\nThis command will enroll a system with the JumpCloud MDM, in DEP. If the system is not enrolled in DEP, the active user of the system will be prompted to approve the MDM profile.\n\n![Dep Prompt](../Files/depPrompt.png)\n\nIf the user clicks the notification window, they'll be brought to the Profiles System Preference panel and prompted to Allow Device Enrollment.\n\n![User Approval](../Files/userApprovalProfile.png)\n\nIf the user clicks allow the device will be DEP enrolled and the MDM profile will become non-removable.\n\n![Enrollment Type](../Files/enrollmentType.png)"
  },
  {
    "name": "Mac - Get logged in user | v1.0 JCCG",
    "type": "mac",
    "script": "```\nstat -f \"%Su\" /dev/console\n```",
    "link": "https://git.io/jccg-Mac-GetLoggedInUsers",
    "description": "The owner of the /dev/console file will reprepsent the currently logged in user to the OSX GUI. This command ouputs this user.\nIf the command returns **root** then no user has signed in and the machine is online at the login screen."
  },
  {
    "name": "Mac - Install Agent and Service Account | v1.3 JCCG",
    "type": "mac",
    "script": "```\n#!/bin/bash\n#\n# Populate the below variables before running the command\n#\n# Enter your connect key within the '' of YOUR_CONNECT_KEY='' with your orgs key found on the new system aside in the admin console\nYOUR_CONNECT_KEY=''\n\n# Enter the SECURETOKEN_ADMIN_USERNAME within the '' of SECURETOKEN_ADMIN_USERNAME=''\nSECURETOKEN_ADMIN_USERNAME=''\n\n# Enter the SECURETOKEN_ADMIN_PASSWORD within the '' of SECURETOKEN_ADMIN_PASSWORD='' with the credentials of the admin with a secure token\nSECURETOKEN_ADMIN_PASSWORD=''\n\n# Flag for installing without checking SECURETOKEN_ADMIN_USERNAME or SECURETOKEN_ADMIN_PASSWORD\nSILENT_INSTALL=0\n\n# Flag for installing without interactive prompts\nUNATTENDED_INSTALL=0\n\n# You can also specify one or more values with parameters\n# -k YOUR_CONNECT_KEY -u SECURETOKEN_ADMIN_USERNAME -p SECURETOKEN_ADMIN_PASSWORD\nwhile getopts k:u:p:shf option; do\n  case \"${option}\" in\n  k) YOUR_CONNECT_KEY=${OPTARG} ;;\n  u) SECURETOKEN_ADMIN_USERNAME=${OPTARG} ;;\n  p) SECURETOKEN_ADMIN_PASSWORD=${OPTARG} ;;\n  h)\n    printf \"Options:\n      -k        Your JumpCloud Connect Key\n      -u        System Admin Username\n      -p        System Admin Password\\n\\n\"\n    exit 0\n    ;;\n  s) SILENT_INSTALL=1 ;;\n  f) UNATTENDED_INSTALL=1 ;;\n  *) echo \"Invalid parameter\"\n     exit 1\n     ;;\n  esac\ndone\n\n#--------------------Do not modify below this line--------------------\n\nMacOSMajorVersion=$(sw_vers -productVersion | cut -d '.' -f 1)\nMacOSMinorVersion=$(sw_vers -productVersion | cut -d '.' -f 2)\nMacOSPatchVersion=$(sw_vers -productVersion | cut -d '.' -f 3)\n\nif [[ $MacOSMajorVersion -eq 10 && $MacOSMinorVersion -lt 13 ]]; then\n  echo \"Error:  Target system is not on macOS 10.13\"\n  exit 2\nelse\n\n  # asks the user to confirm \"y\" or \"n\" before continuing\n  confirmUserContinue() {\n    while true; do\n      read -p 'Continue (y/n)? ' confirmation\n      case \"$confirmation\" in\n        y|Y ) break ;;\n        n|N ) exit 1 ;;\n        * ) echo 'Invalid option. Please enter either \"y\" or \"n\" to continue' ;;\n      esac\n    done\n  }\n\n  # This function checks whether the given user is secure token enabled:\n  secureTokenEnabledForUser() {\n    # secure token is not supported on versions < 10.13\n    if [[ \"$MacOSMajorVersion\" -eq 10 && \"$MacOSMinorVersion\" -lt 13 ]]; then\n      return 1\n    fi\n\n    # on earlier versions of High Sierra, we should use dscl:\n    if [[ \"$MacOSMajorVersion\" -eq 10 && \"$MacOSMinorVersion\" -eq 13 && \"$MacOSPatchVersion\" -lt 4 ]]; then\n      if [[ $(dscl . read /Users/\"$1\" AuthenticationAuthority | grep \";SecureToken;\" -c) -gt 0 ]]; then\n        return 0 # success\n      fi\n    else # on 10.13.4 or higher we can just use sysadminctl to get the secureToken status without admin credentials:\n      if [[ $(sysadminctl -secureTokenStatus \"$1\" 2>&1) == *\"Secure token is ENABLED for user\"* ]]; then\n        return 0 # success\n      fi\n    fi\n\n    return 1 # SecureToken is NOT enabled\n  }\n\n  isAdminUser() {\n    if [ \"$(id -Gn \"$1\" | grep -c -w admin)\" -gt 0 ]; then\n      return 0 # user is an admin\n    fi\n\n    return 1\n  }\n\n  checkAndReadInUsername() {\n    printf \"\\nSecure Token enabled admin required\\n\"\n    printf \"Checking %s for Secure Token admin access\\n\" \"${SECURETOKEN_ADMIN_USERNAME}\"\n    sleep 1\n    if (secureTokenEnabledForUser \"${SECURETOKEN_ADMIN_USERNAME}\") && (isAdminUser \"${SECURETOKEN_ADMIN_USERNAME}\"); then\n      echo \"** ($SECURETOKEN_ADMIN_USERNAME) is verified as a Secure Token admin **\"\n      return 0\n    fi\n    echo \"--------\"\n\n    while ! (secureTokenEnabledForUser \"${SECURETOKEN_ADMIN_USERNAME}\") || ! (isAdminUser \"${SECURETOKEN_ADMIN_USERNAME}\"); do\n      printf \"\\nThe username: %s is not a Secure Token enabled admin.\\nTo enable the JumpCloud Agent to manage FileVault users, \\nplease provide the username of a Secure Token enabled \\nadmin user on this system.\\n\" \"${SECURETOKEN_ADMIN_USERNAME}\"\n      echo \"--------\"\n      read -rp 'Secure Token Admin Username: ' SECURETOKEN_ADMIN_USERNAME\n    done\n\n    echo \"** (${SECURETOKEN_ADMIN_USERNAME}) is verified as a Secure Token admin **\"\n    return 1\n  }\n\n  verifyPasswordForUser() {\n    printf '\\nVerifying Password\\n'\n\n    VERIFYPASSWORD=$(dscl /Local/Default -authonly \"${SECURETOKEN_ADMIN_USERNAME}\" \"${SECURETOKEN_ADMIN_PASSWORD}\")\n\n    if [ -z \"$VERIFYPASSWORD\" ]; then\n      return 0\n    else\n      return 1\n    fi\n  }\n\n  readInPasswordForUser() {\n    while true; do\n      if [ -n \"$SECURETOKEN_ADMIN_PASSWORD\" ]; then\n        if ! verifyPasswordForUser; then\n          printf \"\\nERROR: Incorrect Password for user %s !\\n\" \"${SECURETOKEN_ADMIN_USERNAME}\"\n        else\n          printf \"\\nPassword verified for user %s \\n\" \"${SECURETOKEN_ADMIN_USERNAME}\"\n          break\n        fi\n      else\n        echo 'Password cannot be blank'\n      fi\n\n      read -rsp \"Please enter the password for ${SECURETOKEN_ADMIN_USERNAME}:\" SECURETOKEN_ADMIN_PASSWORD\n      echo ''\n\n    done\n  }\n\n # Install Rosetta2 on M1 (Apple Silicon) Macs if not already installed\n installRosettaForM1() {\n   BIG_SUR_MAJOR=11\n   # Save current IFS (Input Field Separator) state\n   OLDIFS=${IFS}\n   # retrieve OS version info\n   IFS='.' read -r osvers_major osvers_minor osvers_dot_version <<<\"$(/usr/bin/sw_vers -productVersion)\"\n   # restore IFS to previous state\n   IFS=${OLDIFS}\n\n   if [[ ${osvers_major} -ge ${BIG_SUR_MAJOR} ]]; then\n     # Check processor to see if we even need Rosetta2\n     processor=$(/usr/sbin/sysctl -n machdep.cpu.brand_string | grep -o \"Intel\")\n     if [[ -n \"${processor}\" ]]; then\n       echo \"Intel processor installed; no need to install Rosetta2\"\n     else\n       # Check for an installer receipt for Rosetta. If no receipt is found,\n       # perform a non-interactive install of Rosetta.\n       rosetta_check=$(/usr/sbin/pkgutil --pkgs | grep \"com.apple.pkg.RosettaUpdateAuto\")\n       if [[ -z \"${rosetta_check}\" ]]; then\n         if ! /usr/sbin/softwareupdate --install-rosetta --agree-to-license; then\n           echo \"Rosetta installation failed!\"\n         else\n           echo \"Rosetta has been successfully installed.\"\n         fi\n       else\n         echo \"Rosetta is already installed. Nothing to do.\"\n       fi\n     fi\n   else\n     echo \"System is running macOS ${osvers_major}.${osvers_minor}.${osvers_dot_version}.\"\n     echo \"No need to install Rosetta on this version of macOS.\"\n   fi\n } \n\n  # require connect key\n  if [ -z \"$YOUR_CONNECT_KEY\" ]; then\n    echo 'Connect key is required. Please provide one in the script or via the -k parameter'\n    exit 1\n  fi\n\n  # check connect key length\n  if [ ${#YOUR_CONNECT_KEY} != 40 ]; then\n    echo 'Connect key is not 40 characters. Please provide a valid connect key in the script or via the -k parameter'\n    exit 1\n  fi\n\n  # FDA is only needed on Monterey and later\n  if [[ \"$MacOSMajorVersion\" -ge 12 ]]; then\n    FDA_MESSAGE='JumpCloud requires Full Disk Access for our agent to properly configure the PAM Modules for authentication. During installation, System Preferences will open, and Full Disk Access will need to be manually allowed within 5 minutes to successfully complete the installation.'\n    if [ \"$UNATTENDED_INSTALL\" -eq \"0\" ]; then\n      printf \"${FDA_MESSAGE}\\n\\nIf you are installing this with no user session (as root or over SSH), this installation may fail.\\n\\n\"\n      confirmUserContinue\n    else\n      printf \"This command was invoked with the '-f' option disabling any user confirmation.\\n\\n${FDA_MESSAGE}\\n\"\n    fi\n  fi\n\n  if [ \"$SILENT_INSTALL\" -eq \"0\" ]; then\n\n    if [ -z \"${SECURETOKEN_ADMIN_USERNAME}\" ]; then\n      # if empty, set SECURETOKEN_ADMIN_USERNAME to the user running the script\n      SECURETOKEN_ADMIN_USERNAME=$(stat -f '%Su' \"${HOME}\")\n    fi\n\n    # check to make sure the user is a secure token enabled admin\n    checkAndReadInUsername\n    readInPasswordForUser\n\n  fi\n\n  # Install Rosetta2 for M1 (Apple Silicon) Macs\n  installRosettaForM1\n\n  curl --silent --output /tmp/jumpcloud-agent.pkg \"https://s3.amazonaws.com/jumpcloud-windows-agent/production/jumpcloud-agent.pkg\" >/dev/null\n  mkdir -p /opt/jc\n  cat <<-EOF >/opt/jc/agentBootstrap.json\n{\n\"publicKickstartUrl\": \"https://kickstart.jumpcloud.com:443\",\n\"privateKickstartUrl\": \"https://private-kickstart.jumpcloud.com:443\",\n\"connectKey\": \"$YOUR_CONNECT_KEY\"\n}\nEOF\n\n  if [ \"$SILENT_INSTALL\" -eq \"0\" ]; then\n    cat <<-EOF >/var/run/JumpCloud-SecureToken-Creds.txt\n$SECURETOKEN_ADMIN_USERNAME;$SECURETOKEN_ADMIN_PASSWORD\nEOF\n  else\n    cat <<-EOF >/var/run/JumpCloud-SecureToken-Creds.txt\n=skip\nEOF\n  fi\n  # The file JumpCloud-SecureToken-Creds.txt IS DELETED during the agent install process\n  installer -pkg /tmp/jumpcloud-agent.pkg -target /\n  result=$(echo \"$?\")\n  if [[ $result -eq \"0\" ]];then\n    echo \"JumpCloud Agent Installed Successfully\"\n  else\n    echo \"JumpCloud Agent Install Failed\"\n    exit 1\n  fi\nfi\nexit 0\n```",
    "link": "https://git.io/jccg-mac-installagentandserviceaccount",
    "description": "After importing this command the variables YOUR_CONNECT_KEY=\"\", SECURETOKEN_ADMIN_USERNAME=\"\", and SECURETOKEN_ADMIN_PASSWORD=\"\" must populated before the command can be run. This command will only run on MacOS systems running MacOS version 10.13 or later and will install the agent and enable the JumpCloud service account needed to manage FileVault users."
  },
  {
    "name": "Mac - Install Available Updates | v1.0 JCCG",
    "type": "mac",
    "script": "```\nsoftwareupdate -i -a -R\n```",
    "link": "https://git.io/JvLiV",
    "description": "Installs available updates on a Mac system, this command will restart a system if required by the macOS update. This command must be run as root to force the restart. Set the script timeout at 1800 seconds (30 mins) to prevent the command from returning a 124 timeout error, downloading updates could take longer on slower networks. Optionally, remove the '-R' to run this command without restarting."
  },
  {
    "name": "Mac - Install Latest MacOS Installer | v1.0 JCCG",
    "type": "mac",
    "script": "```\n# replace the \"Install macOS Catalaina.app\" text with the version cached on the target system\nmacosinstaller=\"Install macOS Catalina.app\"\n# change the systemGroupID to match the group used in the cache macOS installer command\nsystemGroupID=\"5e74f14e45886d2939ff2562\"\n\nif [[ -d /Applications/${macosinstaller} ]]; then\n    # Parse the systemKey from the conf file.\n    conf=\"$(cat /opt/jc/jcagent.conf)\"\n    regex='\\\"systemKey\\\":\\\"[a-zA-Z0-9]{24}\\\"'\n\n    if [[ $conf =~ $regex ]]; then\n        systemKey=\"${BASH_REMATCH[@]}\"\n    fi\n\n    regex='[a-zA-Z0-9]{24}'\n    if [[ $systemKey =~ $regex ]]; then\n        systemID=\"${BASH_REMATCH[@]}\"\n    fi\n\n    # Get the current time.\n    now=$(date -u \"+%a, %d %h %Y %H:%M:%S GMT\")\n\n    # create the string to sign from the request-line and the date\n    signstr=\"POST /api/v2/systemgroups/${systemGroupID}/members HTTP/1.1\\ndate: ${now}\"\n\n    # create the signature\n    signature=$(printf \"$signstr\" | openssl dgst -sha256 -sign /opt/jc/client.key | openssl enc -e -a | tr -d '\\n')\n\n    curl -s \\\n        -X 'POST' \\\n        -H 'Content-Type: application/json' \\\n        -H 'Accept: application/json' \\\n        -H \"Date: ${now}\" \\\n        -H \"Authorization: Signature keyId=\\\"system/${systemID}\\\",headers=\\\"request-line date\\\",algorithm=\\\"rsa-sha256\\\",signature=\\\"${signature}\\\"\" \\\n        -d '{\"op\": \"remove\",\"type\": \"system\",\"id\": \"'${systemID}'\"}' \\\n        \"https://console.jumpcloud.com/api/v2/systemgroups/${systemGroupID}/members\"\n\n    echo \"JumpCloud system: ${systemID} removed from system group: ${systemGroupID}\"\n\n    # Install latest OS Installer\n    '/Applications/${macosinstaller}/Contents/Resources/startosinstall' --agreetolicense --forcequitapps\nelse\n    echo \"Could not find installer\"\n    exit 1\nfi\n```",
    "link": "https://git.io/JvSeS",
    "description": "This command installs the macOS Installer specified in the macosinstaller variable. Replace \"Install macOS Catalina.app\" with the name of the latest cached installer on the target system. The macosinstaller variable text should include the .app extension. Change the systemGroupID to the same group ID used in the Cache Latest MacOS Installer command. The startosinstall program within the latest OS installer is called with the --agreetolicense and --forcequitapps flags to prevent user interaction. Test that this install method works for for remote users before deploying and consider changing the startosinstall flags if user interaction is required."
  },
  {
    "name": "Mac - Install MDM Profile | v1.2 JCCG",
    "type": "mac",
    "script": "```\n#!/bin/bash\n\n# Force Reinstall MDM Profile (Set to: true)\nreinstall=false\n\n# Verify JumpCloud MDM\nverify_jc_mdm () {\n    # Check the system for the following profileIdentifier\n    mdmID=\"com.jumpcloud.mdm\"\n    check=$(profiles -Lv | grep \"name: $4\" -4 | awk -F\": \" '/attribute: profileIdentifier/{print $NF}')\n    if [[ $check == *$mdmID* ]] ; then\n        echo \"ProfileIdentifier: ${mdmID} found on system. MDM Verified\"\n        if [[ $reinstall = false ]]; then\n            exit 0\n        fi\n    else\n        echo \"JumpCloud MDM profile not found on system.\"\n        exit 1\n    fi\n}\n\n# List profiles\nlist_profiles () {\n    echo \"The following profiles identifiers are installed on this system:\"\n    profiles -Lv | grep \"name: $4\" -4 | awk -F\": \" '/attribute: profileIdentifier/{print $NF}'\n}\n\n# Report if the system is already in the mdm\napproveCheck=$(profiles status -type enrollment | grep \"MDM enrollment:\" | awk 'NF>1{print $NF}')\nif [[ $approveCheck = \"Yes\" ]]; then\n    echo \"An MDM Already installed, not User Approved\"\n    list_profiles\n    verify_jc_mdm\nelif [[ $approveCheck = \"Approved)\" ]]; then\n    echo \"An MDM Already installed and is User Approved\"\n    list_profiles\n    verify_jc_mdm\nelse\n    MDMResult=false\nfi\n\n\n# install the MDM Profile\nif [[ $MDMResult = false ]] || [[ $reinstall = true ]]; then\n    echo \"Installing JumpCloud MDM Profile\"\n    /usr/bin/profiles -I -F /tmp/profile_jc.mobileconfig\nfi\n\n# Verify the installation\nverify_jc_mdm\n```",
    "link": "https://git.io/Jfv5e",
    "description": "Installs the JumpCloud MDM enrollment profile on macOS machines. **Note** your organizations enrollment profile must be uploaded to the \"Files\" section of the configured JumpCloud command for this command to work.\n\n![JC_MDM_Command](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/JC_MDM_Command.png?raw=true)"
  },
  {
    "name": "Mac - List All Users | v1.0 JCCG",
    "type": "mac",
    "script": "```\ndscl . list /Users | grep -v '^_' | grep -v 'daemon' | grep -v 'nobody' | grep -v 'root'\n```",
    "link": "https://git.io/jccg-Mac-ListAllUsers",
    "description": "Lists all users on a Mac"
  },
  {
    "name": "Mac - List Available Updates | v1.0 JCCG",
    "type": "mac",
    "script": "```\nsoftwareupdate -l\n```",
    "link": "https://git.io/jccg-Mac-ListAvailableUpdates",
    "description": "Shows available updates on a Mac system"
  },
  {
    "name": "Mac - Prevent macOS Catalina install | v1.0 JCCG",
    "type": "mac",
    "script": "```\nsoftwareupdate --ignore \"macOS Catalina\"\n```",
    "link": "https://git.io/JeWvf",
    "description": "This command make the software update system preference pane ignore the macOS Catalina installation media. To revert this command run the command `softwareupdate --reset-ignored`"
  },
  {
    "name": "Mac - Prompt Expiring Users To Update Their Password | v1.0 JCCG",
    "type": "mac",
    "script": "```\n## Populate below variable before running command\nJCAPIKey=''\n\n## alertDaysThreshold set to '7' by default.\n## Users whose passwords will expire in 7 days or less will receive a prompt to update.\n## Update the value of the variable alertDaysThreshold=''to modify the threshold.\nalertDaysThreshold='7'\n\n#------- Do not modify below this line ------\nuser=$(ls -la /dev/console | cut -d \" \" -f 4)\n\npasswordExpirationDate=$(\n    curl -s \\\n        -X 'POST' \\\n        -d '{\"filter\":[{\"username\":\"'${user}'\"}],\"fields\" : \"password_expiration_date\"}' \\\n        -H 'Accept: application/json' \\\n        -H 'Content-Type: application/json' \\\n        -H 'x-api-key: '${JCAPIKey}'' \\\n        \"https://console.jumpcloud.com/api/search/systemusers\"\n)\n\nregex=':\".*T'\nif [[ $passwordExpirationDate =~ $regex ]]; then\n    unformattedDate1=\"${BASH_REMATCH[@]}\"\n    unformattedDate2=$(echo \"${unformattedDate1:2}\")\n    expirationDay=${unformattedDate2%?}\n    echo \"${user} password_expiration_date: ${expirationDay}\"\nelse\n    echo \"Could not locate the password expiration date for user ${user}.\"\n    echo \"Is ${user} enabled for password_never_expires?\"\n    echo \"If so users enabled with password_never_expires have no password expiration date.\"\n    exit 1\nfi\n\nToday=\"$(echo $(date -u +%Y-%m-%d))\"\n\ndaysToExpiration=$(echo $((($(date -jf %Y-%m-%d $expirationDay +%s) - $(date -jf %Y-%m-%d $Today +%s)) / 86400)))\necho \"${user} password will expire in ${daysToExpiration} days\"\n\nif [ \"$daysToExpiration\" -le \"$alertDaysThreshold\" ]; then\n    echo \"${daysToExpiration} within alertDaysThreshold of ${alertDaysThreshold} prompting user\"\n    userPrompt=$(sudo -u $user osascript -e 'display dialog \"Your JumpCloud password will expire in '\"${daysToExpiration}\"' days.\\nClick on the JumpCloud icon in your menu bar and reset your password, so you do not lose access to critical resources.\" with title \"JumpCloud Password Expiration Warning\" with icon file \"Applications:Jumpcloud.app:Contents:Resources:AppIcon.icns\"' 2>/dev/null)\n    echo \"$userPrompt\"\n\nelse\n    echo \"${daysToExpiration} NOT within alertDaysThreshold of ${alertDaysThreshold} NOT prompting user\"\n\nfi\n\nexit 0\n```",
    "link": "https://git.io/fh5qZ",
    "description": "Queries the current signed in user's password expiration date and determines if this date is set to expire within the threshold set for the variable `alertDaysThreshold='7'`.\n\nBy default this value is set to 7 days.\n\nIf it is determined that the users password will expire within the alert days threshold then a notification is displayed to the user.\n\n![Mac_PasswordExpiration_Notification](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/Mac_PasswordExpiration_Notification.png?raw=true)"
  },
  {
    "name": "Mac - Prompt Users To Update Password With Expiration Date Logic | v1.0 JCCG",
    "type": "mac",
    "script": "```\n# Populate below variable before running command\nJCAPIKey=''\n\n#------- Do not modify below this line ------\nuser=$(ls -la /dev/console | cut -d \" \" -f 4)\necho \"Signed in user: ${user}\"\n\n# Captures password expiration policy for organization\norgSettings=$(\n    curl -s \\\n        -X 'GET' \\\n        -H 'Accept: application/json' \\\n        -H 'Content-Type: application/json' \\\n        -H 'x-api-key: '${JCAPIKey}'' \\\n        \"https://console.jumpcloud.com/api/settings/\"\n)\n\nregex='\"passwordExpirationInDays\":.*'\n\nif [[ $orgSettings =~ $regex ]]; then\n    unformattedExpirationDays1=\"${BASH_REMATCH[@]}\"\n    passwordExpirationPolicyInDays=$(echo $unformattedExpirationDays1 | cut -d : -f 2 | cut -d , -f 1)\nfi\n\n# Captures password expiration date for logged in user\npasswordExpirationDate=$(\n    curl -s \\\n        -X 'POST' \\\n        -d '{\"filter\":[{\"username\":\"'${user}'\"}],\"fields\" : \"password_expiration_date\"}' \\\n        -H 'Accept: application/json' \\\n        -H 'Content-Type: application/json' \\\n        -H 'x-api-key: '${JCAPIKey}'' \\\n        \"https://console.jumpcloud.com/api/search/systemusers\"\n)\n\nregex=':\".*T'\nif [[ $passwordExpirationDate =~ $regex ]]; then\n    unformattedDate1=\"${BASH_REMATCH[@]}\"\n    unformattedDate2=$(echo \"${unformattedDate1:2}\")\n    expirationDay=${unformattedDate2%?}\n    echo \"Password_expiration_date: ${expirationDay}\"\nelse\n    echo \"Could not locate password expiration date\"\n    exit 1\nfi\n\nToday=\"$(echo $(date -u +%Y-%m-%d))\"\n\n# Calculates days to expiration\ndaysToExpiration=$(echo $((($(date -jf %Y-%m-%d $expirationDay +%s) - $(date -jf %Y-%m-%d $Today +%s)) / 86400)))\necho \"Days Until Password Expires: ${daysToExpiration} days\"\n\n# Compares days to expiration $passwordExpirationPolicyInDays variable\nif [ \"$daysToExpiration\" -lt \"$passwordExpirationPolicyInDays\" ]; then\n    userPrompt=$(sudo -u $user osascript -e 'display dialog \"Please update your JumpCloud password immediately. \\n\\nClick on the JumpCloud icon in your menu bar to update your password.\" with title \"Update Your JumpCloud Password Immediately\" with icon file \"Applications:Jumpcloud.app:Contents:Resources:AppIcon.icns\" giving up after 120' 2>/dev/null)\n\n    if [ \"$userPrompt\" = \"button returned:OK, gave up:false\" ]; then\n        echo \"User input: button returned:Ok\"\n        echo \"Password update: Pending\"\n\n    else\n        echo \"User input: $userPrompt\"\n        echo \"Details: Timeout\"\n        echo \"Password update: Pending\"\n        exit 1\n    fi\nelse\n\n    echo echo \"Password update: Completed\"\n\nfi\n\nexit 0\n\n```",
    "link": "https://git.io/fhpfV",
    "description": "If the signed in user has not reset their password on the day the command is run then a notification is sent to the user. **This logic allows the command to be set to run as a repeating on a set of target systems and will only re-prompt users who do not take action and update their passwords.**\n\n\nRequired Variables:\n* JCAPIKEY - This must be populated with your API key.\n* Password aging must be enabled in the JumpCloud Organization settings.\n\n![Mac_PasswordUpdate_Notification](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/Mac_PasswordUpdate_Notification.png?raw=true)"
  },
  {
    "name": "Mac - Prompt Users To Update Their Password | v1.0 JCCG",
    "type": "mac",
    "script": "```\nuser=$(ls -la /dev/console | cut -d \" \" -f 4)\n\necho \"Signed in user: ${user}\"\n\nuserPrompt=$(sudo -u $user osascript -e 'display dialog \"Please update your JumpCloud password immediately. \\n\\nClick on the JumpCloud icon in your menu bar to update your password.\" with title \"Update Your JumpCloud Password Immediately\" with icon file \"Applications:Jumpcloud.app:Contents:Resources:AppIcon.icns\" giving up after 120' 2>/dev/null)\n\nif [ \"$userPrompt\" = \"button returned:OK, gave up:false\" ]; then\n    echo \"User input: button returned:Ok\"\n\nelse\n    echo \"User input: $userPrompt\"\n    echo \"Details: Timeout\"\n    exit 1\nfi\n```",
    "link": "https://git.io/fhpfz",
    "description": "Displays a notification to the signed in user and informs them to update their password using the JumpCloud Menubar app.\n\n![Mac_PasswordUpdate_Notification](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/Mac_PasswordUpdate_Notification.png?raw=true)"
  },
  {
    "name": "Mac - Pull Workspace ONE UEM zero-touch log | v1.0 JCCG",
    "type": "mac",
    "script": "```\ncat /tmp/jc-zero-touch_log.txt\n```",
    "link": "https://git.io/fjeAJ",
    "description": "Pulls the jc-zero-touch_log from a Mac system. This log is produced as output from the Workspace ONE UEM zero-touch macOS onboarding workflow."
  },
  {
    "name": "Mac - Pull jcagent.log | v1.1 JCCG",
    "type": "mac",
    "script": "```\n#!/bin/bash\nagentLogFile=\"/var/log/jcagent.log\"\necho \"============================= Begin Log ===============================\"\n# Pull log data and echo to standard out\nwhile IFS=\"\" read -r line; do\n    echo \"$line\"\ndone < $agentLogFile\necho \"============================== End Log ================================\"\n```",
    "link": "https://git.io/jccg-Mac-Pulljcagent.log",
    "description": "Pulls the JC agent log from a Mac system and prints each line to the JumpCloud command result log. This log can be saved as a .log file."
  },
  {
    "name": "Mac - Refresh Login Window  |  v1.0 JCCG",
    "type": "mac",
    "script": "```\nloginWindowProccess=\"$(ps -Ajc | grep loginwindow | awk '{print $2}')\"\nkill -9 $loginWindowProccess\n```",
    "link": "https://git.io/fhQDF",
    "description": "Refreshes the Mac login window by restarting the login window process. This can be used to reveal a user who was locked out on a Mac machine but has been unlocked without restarting the machine.\n\n**Warning** if run when a user is signed in this command will sign them out and bring them to the login screen."
  },
  {
    "name": "Mac - Rename System HostName, LocalHostName and ComputerName from JumpCloud | v2.0 JCCG",
    "type": "mac",
    "script": "```\n#!/bin/bash\n################################################################################\n# This script will update the system hostname, localHostname & computerName to\n# match the value of this systems displayName in the JumpCloud console.\n# An API Key with read access is required to run this script.\n################################################################################\n\n# Set Read API KEY - Required to read \"DisplayName\" from console.jumpcloud.com\nAPI_KEY=\"YourReadOnlyAPIKey\"\n\n# ------- Do not modify below this line ------\n# Functions\nfunction validateVariable() {\n    var=$1\n    if [[ -z \"$var\" ]]; then\n        echo \"[error] Required variable was null, exiting...\"\n        exit 1\n    fi\n} >&2\nfunction validateLocalHostname() {\n    var=$1\n    # Validate LocalHostName is Alphanumeric, contains '-' and no spaces\n    # Attempt to remove the space characters if they exist\n    if [[ \"$var\" =~ \\ |\\' ]]; then\n        echo \"[debug] whitespace characters found in LocalHostName, removing...\"\n        var=\"${var//[[:blank:]]/}\"\n    fi\n    # Check for special characters & length of 63 characters\n    # does not begin or end with '-'\n    if [[ \"$var\" =~ ^[^-][a-zA-Z0-9-]{1,63}[^-]$ ]]; then\n        echo \"[debug] LocalHostname appears to be valid: $var\"\n    else\n        echo \"[debug] special characters found in LocalHostname, removing...\"\n        # Attempt to remove special characters if they exist\n        var=$(echo \"$var\" | sed \"s/[^[:alnum:]-]//g\")\n        # Finally validate updated variable\n        if [[ \"$var\" =~ ^[^-][a-zA-Z0-9-]{1,63}[^-]$ ]]; then\n            echo \"[debug] LocalHostname appears to be valid: $var\"\n        else\n            echo \"[error] LocalHostName could not be set, exiting\"\n            exit 1\n        fi\n    fi\n    validatedHostname=\"$var\"\n}\n# Get System Key\nfunction getSystemKey() {\n    conf=\"$(cat /opt/jc/jcagent.conf)\"\n    regex='\\\"systemKey\\\":\\\"[a-zA-Z0-9]{24}\\\"'\n    if [[ $conf =~ $regex ]]; then\n        systemKey=\"${BASH_REMATCH[@]}\"\n    fi\n    # echo \"$(date \"+%Y-%m-%dT%H:%M:%S\"): systemKey = $systemKey \"\n    regex='[a-zA-Z0-9]{24}'\n    if [[ $systemKey =~ $regex ]]; then\n        systemID=\"${BASH_REMATCH[@]}\"\n    fi\n    # echo \"$(date \"+%Y-%m-%dT%H:%M:%S\"): systemID = $systemID \"\n    echo \"$systemID\"\n}\nsystemID=$(getSystemKey)\nsearch=$(\n    curl -s -f -X GET https://console.jumpcloud.com/api/systems/${systemID} \\\n        -H 'Accept: application/json' \\\n        -H 'Content-Type: application/json' \\\n        -H \"x-api-key: ${API_KEY}\"\n)\n# regex pattern to search displayNames. This pattern selects the text after \"displayName\":\" and before \",\nregex='(\"displayName\":\")([^\"]*)(\",)'\nif [[ $search =~ $regex ]]; then\n    match=\"${BASH_REMATCH[2]}\"\nfi\n\n# Get old system name\noldName=$(scutil --get HostName)\n# If hostname is not set for any reason, try again with localHostName\nif [[ \"$oldName\" == \"\" ]];then\n    echo \"[debug] HostName was not set, trying to get the LocalHostName\"\n    oldName=$(scutil --get LocalHostName)\nfi\n# Validate oldName, Match (new Name), systemID\nvalidateVariable \"$oldName\"\nvalidateVariable \"$systemID\"\nvalidateVariable \"$match\"\necho \"[status] Attempting to set ComputerName, LocalHostName & Hostname to: $match\"\n# Validate localHostName is alphanumeric, 63 chars in length & no special chars\nvalidateLocalHostname \"$match\"\n# if validatedHostname variable exists, continue\nvalidateVariable \"$validatedHostname\"\necho \"[debug] script variables were validated\"\n# set the hostname, LocalHostName and computer name\n# hostname:\nscutil --set HostName \"$match\"\nif [[ $? -eq 0 ]]; then\n    echo \"[status] HostName Set: $(scutil --get HostName)\"\nelse\n    echo \"[error] Hostname was not set\"\n    exit 1\nfi\n\n\nif validateVariable \"$validatedHostname\"; then\n    # Set validated variable\n    scutil --set LocalHostName \"$validatedHostname\"\n    if [[ $? -eq 0 ]]; then\n        echo \"[status] LocalHostName Set: $(scutil --get LocalHostName)\"\n    else\n        echo \"[error] LocalHostName was not set\"\n        exit 1\n    fi\nelse\n    echo \"[error] Could not validate LocalHostName\"\n    exit 1\nfi\nscutil --set ComputerName \"$match\"\nif [[ $? -eq 0 ]]; then\n    echo \"[status] ComputerName Set: $(scutil --get ComputerName)\"\nelse\n    echo \"[error] ComputerName was not set\"\n    exit 1\nfi\n\necho \"[status] $oldName was renamed to $match\"\nexit 0\n```",
    "link": "https://git.io/JvFq6",
    "description": "This script uses a read only API key to gather info about the current system. Using Regex, the code filters out the displayName of a given system and sets the system HostName, LocalHostName and ComputerName to the name set in the JumpCloud console.\n\nPlease note, there are specific rules for the LocalHostName value. LocalHostNames must:\n\n* Be a maximum 63 characters in length\n* Contain no whitespace characters\n* Contain only alphanumeric characters and hyphens '-'\n* Hyphens must not exist at the beginning or end of the string ex. '-system-1-' is not allowed\n\nThis script will attempt to strip whitespace and special characters before setting the system's LocalHostName. HostNames and ComputerNames are not modified as their requirements differ from the LocalHostName."
  },
  {
    "name": "Mac - Restart System | v1.0 JCCG",
    "type": "mac",
    "script": "```\nsudo shutdown -r now\n```",
    "link": "https://git.io/jccg-Mac-RestartSystem",
    "description": "Restarts a Mac system without user prompt or warning."
  },
  {
    "name": "Mac - Run Once Template - Remove System From Associated System Group | v1.0 JCCG",
    "type": "mac",
    "script": "```\n# Populate systemGroupID variable before running the command\n\nsystemGroupID=''\n\n#--------------------Enter command below this line--------------------\n\n\n#--------------------Do not modify below this line--------------------\n\n# Parse the systemKey from the conf file.\nconf=\"$(cat /opt/jc/jcagent.conf)\"\nregex='\\\"systemKey\\\":\\\"[a-zA-Z0-9]{24}\\\"'\n\nif [[ $conf =~ $regex ]]; then\n\tsystemKey=\"${BASH_REMATCH[@]}\"\nfi\n\nregex='[a-zA-Z0-9]{24}'\nif [[ $systemKey =~ $regex ]]; then\n\tsystemID=\"${BASH_REMATCH[@]}\"\nfi\n\n# Get the current time.\nnow=$(date -u \"+%a, %d %h %Y %H:%M:%S GMT\")\n\n# create the string to sign from the request-line and the date\nsignstr=\"POST /api/v2/systemgroups/${systemGroupID}/members HTTP/1.1\\ndate: ${now}\"\n\n# create the signature\nsignature=$(printf \"$signstr\" | openssl dgst -sha256 -sign /opt/jc/client.key | openssl enc -e -a | tr -d '\\n')\n\ncurl -s \\\n\t-X 'POST' \\\n\t-H 'Content-Type: application/json' \\\n\t-H 'Accept: application/json' \\\n\t-H \"Date: ${now}\" \\\n\t-H \"Authorization: Signature keyId=\\\"system/${systemID}\\\",headers=\\\"request-line date\\\",algorithm=\\\"rsa-sha256\\\",signature=\\\"${signature}\\\"\" \\\n\t-d '{\"op\": \"remove\",\"type\": \"system\",\"id\": \"'${systemID}'\"}' \\\n\t\"https://console.jumpcloud.com/api/v2/systemgroups/${systemGroupID}/members\"\n\necho \"JumpCloud system: ${systemID} removed from system group: ${systemGroupID}\"\n```",
    "link": "https://git.io/fxU15",
    "description": "This template can be modified to satisfy use cases where admins wish to run a command once on a number of target systems and have the system automatically removed from the system group which associates the system with the command.\n\n*Directly associating JumpCloud systems to JumpCloud commands? [No problem refer to this template for removing systems from a JumpCloud command](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Run%20Once%20Template%20-%20Remove%20System%20From%20Command.md)*\n\nBefore running this command the variable **systemGroupID=''** must be populated.\n\nTo find the systemGroupID for a JumpCloud system group navigate to the \"GROUPS\" section of the JumpCloud admin portal and select the system group to bring up the system group details. Within the URL of the selected command the systemGroupID will be the 24 character string between 'system/' and '/details'. The JumpCloud PowerShell command [Get-JCGroup](https://github.com/TheJumpCloud/support/wiki/Get-JCGroup) can also be used to find the systemGroupID. The systemGroupID is the 'id' value which will be displayed for each JumpCloud group when Get-JCGroup is called.\n\n![systemGroupID example](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/systemGroupID.png?raw=true)\n\nEnter the payload of the command under the line '#--------------------Enter command below this line--------------------'\n\nAfter the command is run the system is removed from the system group specified via the JumpCloud system context API. [Learn more about the JumpCloud system context API here](https://docs.jumpcloud.com/2.0/authentication-and-authorization/system-context)."
  },
  {
    "name": "Mac - Run Once Template - Remove System From Command | v1.0 JCCG",
    "type": "mac",
    "script": "```\n# Populate commandID variable before running the command\n\ncommandID=''\n\n#--------------------Enter command below this line--------------------\n\n\n#--------------------Do not modify below this line--------------------\n\n# Parse the systemKey from the conf file.\nconf=\"$(cat /opt/jc/jcagent.conf)\"\nregex='\\\"systemKey\\\":\\\"[a-zA-Z0-9]{24}\\\"'\n\nif [[ $conf =~ $regex ]]; then\n\tsystemKey=\"${BASH_REMATCH[@]}\"\nfi\n\nregex='[a-zA-Z0-9]{24}'\nif [[ $systemKey =~ $regex ]]; then\n\tsystemID=\"${BASH_REMATCH[@]}\"\nfi\n\n# Get the current time.\nnow=$(date -u \"+%a, %d %h %Y %H:%M:%S GMT\")\n\n# create the string to sign from the request-line and the date\nsignstr=\"POST /api/v2/systems/${systemID}/associations?targets=command HTTP/1.1\\ndate: ${now}\"\n\n# create the signature\nsignature=$(printf \"$signstr\" | openssl dgst -sha256 -sign /opt/jc/client.key | openssl enc -e -a | tr -d '\\n')\n\ncurl -s \\\n\t-X 'POST' \\\n\t-H 'Content-Type: application/json' \\\n\t-H 'Accept: application/json' \\\n\t-H \"Date: ${now}\" \\\n\t-H \"Authorization: Signature keyId=\\\"system/${systemID}\\\",headers=\\\"request-line date\\\",algorithm=\\\"rsa-sha256\\\",signature=\\\"${signature}\\\"\" \\\n\t-d '{\"op\": \"remove\",\"type\": \"command\",\"id\": \"'${commandID}'\"}' \\\n\t\"https://console.jumpcloud.com/api/v2/systems/${systemID}/associations?targets=command\"\n\necho \"JumpCloud system: ${systemID} removed from command target list\"\n```",
    "link": "https://git.io/fxUDb",
    "description": "This template can be used to satisfy use cases where admins wish to run a command once on a number of target systems and have the system automatically removed from the commands system target list after the command is run.\n\n*Using a system group for associating systems with JumpCloud commands? [No problem refer to this template for removing systems from a JumpCloud command from an associated JumpCloud system group](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Mac%20Commands/Mac%20-%20Run%20Once%20Template%20-%20Remove%20System%20From%20Associated%20System%20Group.md).*\n\nBefore running this command the variable **commandID=''** must be populated.\n\n![commanID example](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/commandID.png?raw=true)\n\nTo find the commandID within the JumpCloud admin console select the command to expand the command details. Within the URL of the selected command the commandID will be the 24 character string between 'commands/' and '/details'. The JumpCloud PowerShell command [Get-JCCommand](https://github.com/TheJumpCloud/support/wiki/Get-JCCommand) can also be used to find the commandID which will reveal the commandID in the '_id' field.\n\nEnter the payload of the command under the line '#--------------------Enter command below this line--------------------'\n\nAfter the command is run the system is removed from the command via the JumpCloud system context API. [Learn more about the JumpCloud system context API here](https://docs.jumpcloud.com/2.0/authentication-and-authorization/system-context)."
  },
  {
    "name": "Mac - Set Agent Log Level to Debug | v1.0 JCCG",
    "type": "mac",
    "script": "```\n#!/bin/bash\n\n# File Locations\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogdebug.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Write the daemon\ncat <<EOF > $launchDaemon\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>Label</key>\n\t<string>com.jumpcloud.agentlogdebug</string>\n\t<key>ProgramArguments</key>\n\t<array>\n\t\t<string>/bin/bash</string>\n\t\t<string>/var/tmp/jc_setAgent.sh</string>\n\t</array>\n    <key>RunAtLoad</key>\n\t<true/>\n</dict>\n</plist>\nEOF\n\n# Create the script file:\ncat <<'EOF' > $scriptFile\n#!/bin/bash\n\n# Set Debug Level | Either \"DEBUG\" or \"TRACE\"\nsetLevel=\"DEBUG\"\n\n# Sleep 10s to let wrapper command exit 0\nsleep 10\n\n# File Locations\nlogLevelFile=\"/opt/jc/loglevel.cache\"\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogdebug.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\nlogLevel () {\n    # Valid Log Levels\n    list=(\"DEBUG\" \"TRACE\")\n    if [[ ${list[*]} =~ $1 ]]; then\n        echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Setting JumpCloud-Agent debug Level to $1\"\nprintf $1 > $logLevelFile\n\n    echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Log Level Set to: $(cat $logLevelFile)\"\n    else\n        echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Error setting log level, run script with elevated permissions\"\n        exit 1\n    fi\n}\n\n# Call LogLevel Function to set log level\nlogLevel $setLevel\n\n# Restart Agent to start logging with new level\nlaunchctl stop com.jumpcloud.darwin-agent\n\n# Clean up after restarting agent\n# Remove launchDaemon\nrm $launchDaemon\n# Remove this script\nrm -- \"$0\"\nEOF\n\n# Load the Daemon\nlaunchctl load -w $launchDaemon\n\nexit 0\n```",
    "link": "https://git.io/JUUdN",
    "description": "This command will set the JumpCloud Agent Log Level to Debug. The log level can be set to trace by setting the `setLevel=\"DEBUG\"` variable to `setLevel=\"TRACE\"` After the command is run, a launchDaemon is triggered which loads a second script to set the log Level. That second script restarts the JumpCloud Agent and removes the launchDaemon and deletes itself. The launchDameon: com.jumpcloud.agentlogdefault.plist will be unloaded on system restart."
  },
  {
    "name": "Mac - Set Agent Log Level to Default | v1.0 JCCG",
    "type": "mac",
    "script": "```\n#!/bin/bash\n\n# File Locations\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogdefault.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Write the daemon\ncat <<EOF > $launchDaemon\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>Label</key>\n\t<string>com.jumpcloud.agentlogdefault</string>\n\t<key>ProgramArguments</key>\n\t<array>\n\t\t<string>/bin/bash</string>\n\t\t<string>/var/tmp/jc_setAgent.sh</string>\n\t</array>\n    <key>RunAtLoad</key>\n\t<true/>\n</dict>\n</plist>\nEOF\n\n# Create the script file:\ncat <<'EOF' > $scriptFile\n#!/bin/bash\n\n# Sleep 10s to let wrapper command exit 0\nsleep 10\n\n# File Locations\nlogLevelFile=\"/opt/jc/loglevel.cache\"\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogdefault.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Read $logLevelFile, if exists, delete\nif [[ -f $logLevelFile ]]; then\n    rm $logLevelFile\nfi\n\n# Restart Agent to start logging with new level\nlaunchctl stop com.jumpcloud.darwin-agent\n\n# Clean up after restarting agent\n# Remove launchDaemon\nrm $launchDaemon\n# Remove this script\nrm -- \"$0\"\nEOF\n\n# Load the Daemon\nlaunchctl load -w $launchDaemon\n\nexit 0\n```",
    "link": "https://git.io/JUUdA",
    "description": "This command will set the JumpCloud Agent Log Level back to the default setting. After the command is run, a launchDaemon is triggered which loads a second script to set the Log Level. That second script restarts the JumpCloud Agent and removes the launchDaemon and deletes itself. The launchDameon: com.jumpcloud.agentlogdefault.plist will be unloaded on system restart."
  },
  {
    "name": "Mac - Set Agent Log Level to Trace | v1.0 JCCG",
    "type": "mac",
    "script": "```\n#!/bin/bash\n\n# File Locations\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogtrace.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\n# Write the daemon\ncat <<EOF > $launchDaemon\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>Label</key>\n\t<string>com.jumpcloud.agentlogtrace</string>\n\t<key>ProgramArguments</key>\n\t<array>\n\t\t<string>/bin/bash</string>\n\t\t<string>/var/tmp/jc_setAgent.sh</string>\n\t</array>\n    <key>RunAtLoad</key>\n\t<true/>\n</dict>\n</plist>\nEOF\n\n# Create the script file:\ncat <<'EOF' > $scriptFile\n#!/bin/bash\n\n# Set Debug Level | Either \"DEBUG\" or \"TRACE\"\nsetLevel=\"TRACE\"\n\n# Sleep 10s to let wrapper command exit 0\nsleep 10\n\n# File Locations\nlogLevelFile=\"/opt/jc/loglevel.cache\"\nlaunchDaemon=\"/Library/LaunchDaemons/com.jumpcloud.agentlogtrace.plist\"\nscriptFile=\"/var/tmp/jc_setAgent.sh\"\n\nlogLevel () {\n    # Valid Log Levels\n    list=(\"DEBUG\" \"TRACE\")\n    if [[ ${list[*]} =~ $1 ]]; then\n        echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Setting JumpCloud-Agent debug Level to $1\"\nprintf $1 > $logLevelFile\n\n    echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Log Level Set to: $(cat $logLevelFile)\"\n    else\n        echo \"$(date \"+%Y-%m-%d %H:%M:%S\"): Error setting log level, run script with elevated permissions\"\n        exit 1\n    fi\n}\n\n# Call LogLevel Function to set log level\nlogLevel $setLevel\n\n# Restart Agent to start logging with new level\nlaunchctl stop com.jumpcloud.darwin-agent\n\n# Clean up after restarting agent\n# Remove launchDaemon\nrm $launchDaemon\n# Remove this script\nrm -- \"$0\"\nEOF\n\n# Load the Daemon\nlaunchctl load -w $launchDaemon\n\nexit 0\n```",
    "link": "https://git.io/JUy8T",
    "description": "This command will set the JumpCloud Agent Log Level to Trace. The log level can be set to trace by setting the `setLevel=\"DEBUG\"` variable to `setLevel=\"TRACE\"` After the command is run, a launchDaemon is triggered which loads a second script to set the log Level. That second script restarts the JumpCloud Agent and removes the launchDaemon and deletes itself. The launchDameon: com.jumpcloud.agentlogdefault.plist will be unloaded on system restart."
  },
  {
    "name": "Mac - Set Auto Logout Delay | v1.0 JCCG",
    "type": "mac",
    "script": "```\n\n# Update the AutoLogOutDelay Variable\n# This variable is defined in seconds by displayed as a minutes in System Preferences\n# The minimum number of minutes this payload can take is 5 minutes (300 seconds)\n# The maximum value this payload can take is 60 minutes (3600 seconds)\n# To disable this setting set the value to 0\n\nAutoLogOutDelay='300'\n\n#------- Do not modify below this line ------\n\nif [ \"$AutoLogOutDelay\" -ge 300 -a \"$AutoLogOutDelay\" -le 3600 ]; then\n    echo \"Enabing AutoLogOutDelay\"\nelif [ \"$AutoLogOutDelay\" -eq 0 ]; then\n    echo \"Disabling AutoLogOutDelay\"\nelse echo \"$AutoLogOutDelay is not a valid value. Set AutoLogOutDelay to a number between 300 and 3600 or 0 to disable\" exit 2; fi\n\nsudo defaults write /Library/Preferences/.GlobalPreferences.plist com.apple.autologout.AutoLogOutDelay -int $AutoLogOutDelay\nsleep 2\nsudo defaults read /Library/Preferences/.GlobalPreferences.plist com.apple.autologout.AutoLogOutDelay\n```",
    "link": "https://git.io/JeY0v",
    "description": "This command will enable the macOS setting to auto log out a machine after \"X\" minutes of inactivity.\n\nThe input variable for this command `AutoLogOutDelay` takes in a value between 300 and 3600 seconds.\nThis is represented in the System Preferences pane in minutes under the tab \"Security & Privacy\" > \"Advanced\" in the field \"Log out after X minutes of inactivity\".\n\nIf the value specified for the `AutoLogOutDelay` is set to 0 this will disable the setting and turn off the AutoLogOutDelay setting."
  },
  {
    "name": "Mac - Set Desktop Background | v2.1 JCCG",
    "type": "mac",
    "script": "```\n## *** Customize ***\n  # 1. Update the 'backgroundURL' to the URL of your desired desktop image. A JumpCloud image is used by default.\n  backgroundURL=\"https://raw.githubusercontent.com/TheJumpCloud/support/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/JumpCloud_Background.png\"\n  # 2. Ensure the 'fileType' matches the file type of the desktop image (change to jpg if using a jpg). 'png' is set by default.\n  fileType=\"png\"\n  # ------------Do not modify below this line-------------\n  date_val=$(date \"+%Y-%m-%d-%H%M\")\n  backgroundFile=/Users/Shared/desktopimage_$date_val.$fileType\n  curl -s -o \"$backgroundFile\" \"$backgroundURL\"\nread -r -d '' PSCRIPT<<EOF\nfrom AppKit import NSWorkspace, NSScreen\nfrom Foundation import NSURL\n# generate a fileURL for the desktop picture\nfile_url = NSURL.fileURLWithPath_('$backgroundFile')\n# make image options dictionary\n# we just make an empty one because the defaults are fine\noptions = {}\n# get shared workspace\nws = NSWorkspace.sharedWorkspace()\n# iterate over all screens\nfor screen in NSScreen.screens():\n    # tell the workspace to set the desktop picture\n    (result, error) = ws.setDesktopImageURL_forScreen_options_error_(\n                file_url, screen, options, None)\nEOF\n  env python -c \"$PSCRIPT\"\n```",
    "link": "https://git.io/jccg-Mac-SetDesktopBackground",
    "description": "The \"JumpCloud_Background.png\" file is downloaded to the local machine and saved in the folder \"/Users/Shared\"/\n\nTo modify this command to download and set a background image of your choice follow the steps under '*** Customize ***' by updating the backgroundURL and corresponding fileType variables.\n\nThis command used in tandem with the wallpaper modification Mac policy can be used to set and then prevent end users from updating their background.\n\nThis command can be built manually as a Mac command where the 'run-as' user is set to the JC managed user on that machine and can not be executed as the root user."
  },
  {
    "name": "Mac - Verify JumpCloud Service Account | v1.1 JCCG",
    "type": "mac",
    "script": "```\n#!/bin/bash\n\nMacOSMajorVersion=$(sw_vers -productVersion | cut -d '.' -f 1)\nMacOSMinorVersion=$(sw_vers -productVersion | cut -d '.' -f 2)\nMacOSPatchVersion=$(sw_vers -productVersion | cut -d '.' -f 3)\n\nif [[ $MacOSMajorVersion -eq 10 && $MacOSMinorVersion -lt 13 ]]; then\n    echo \"Error:  System must be running 10.13+ to install Service Account.\"\n    exit 2\nfi\n\n# Gather the local accounts on the system\nlocalAccounts=$(dscl . list /Users UniqueID | awk '$2>500{print $1}' | grep -v super.admin | grep -v _jumpcloudserviceaccount)\n# For each local account, test secure token status\nfor usr in ${localAccounts};\ndo\n    testST=$(sysadminctl -secureTokenStatus \"$usr\" 2>&1)\n    # echo $testST\n    if [[ $testST == *ENABLED* ]]\n    then\n        echo \"$usr has secure token\"\n    fi\ndone\n\nJCSA_Username=\"_jumpcloudserviceaccount\"\nJCSA_FullName=\"JumpCloud Service Account\"\nJCSA_FullName2=\"JumpCloud\"\n\nsysadmin_name=\"sysadminctl\"\nif [[ $MacOSMinorVersion -eq 13 ]]; then\n    if [[ $MacOSPatchVersion -lt 4 ]]; then\n        sysadmin_name=\"/opt/jc/bin/sysadminkludge\"\n    fi\nfi\n\nresult=$($sysadmin_name -secureTokenStatus $JCSA_Username 2>&1 )\nunknown_user=$(echo $result | grep \"Unknown user $JCSA_Username\")\nnewEnabled=$(echo $result | grep \"Secure token is ENABLED for user $JCSA_FullName2\")\n\nif [[ ! -z $unknown_user ]]; then\n    echo \"Error:  JumpCloud Service Account not installed\"\n    exit 2\nfi\n\nif [[ -z $newEnabled ]]; then\n    oldEnabled=$(echo $result | grep \"Secure token is ENABLED for user $JCSA_FullName\")\n        if [[ -z $oldEnabled ]]; then\n                echo \"Error:  JumpCloud Service Account does not have a secure token\"\n                exit 3\n        fi\nfi\n\necho \"Success: JumpCloud Service Account has been properly created\"\nexit 0\n```",
    "link": "https://git.io/jccg-mac-verifyjumpcloudserviceaccount",
    "description": "The above command will verify the presence of the JumpCloud service account needed to manage users on MacOS systems on 10.13 where APFS drives are used and FileVault is enabled."
  },
  {
    "name": "Windows - 64-Bit Command | v1.0 JCCG",
    "type": "windows",
    "script": "```\n## Enter the command within the \"\" on the below line\n\n$64BitCommand = \"\"\n\n#------ Do not modify below this line ---------------\n\n& (Join-Path ($PSHOME -replace 'syswow64', 'sysnative') powershell.exe) -Command \"& {$64BitCommand}\"\n```",
    "link": "https://git.io/jccg-windows-64-bitcommand",
    "description": "A template to use to execute PowerShell commands in the 64-bit environment. By default, all JumpCloud PowerShell commands are executed in the 32-bit PowerShell environment. Some commands are only available for execution in the 64-bit environment. \n\nTo determine if a command is 32 or 64-bit discovery can be done using the command Get-Command to find the module that a command is loaded in and then checking for that module in a 32-bit session.\n\nThe command Get-LocalUser is only available in the 64-bit environment.\n\nWe can see this by using the Get-Command function and passing in the Get-LocalUser command.\n\nExample \n```PowerShell\nGet-Command Get-LocalUser\n\nCommandType     Name                                               Version    Source\n-----------     ----                                               -------    ------\nCmdlet          Get-LocalUser                                      1.0.0.0    Microsoft.PowerShell.LocalAccounts\n\n```\nThe Get-LocalUser command shows the source of the Get-LocalUser command is the **Microsoft.PowerShell.LocalAccounts** module.\n\nWhen running Get-Module in the 32-bit environment, the output reveals that this module is not loaded and therefore any of the commands within the module are not accessible.\n\nExample from **32-bit shell:**\n```PowerShell\nGet-Module | Select-Object ModuleType, Version, Name\n\nModuleType Version Name\n---------- ------- ----\n  Manifest 3.1.0.0 Microsoft.PowerShell.Management\n  Manifest 3.1.0.0 Microsoft.PowerShell.Utility\n\n```\n\nWhen running the Get-Module command in the 64-bit environment we can see the **Microsoft.PowerShell.LocalAccounts**. \n\nExample from **64-bit shell:**\n```PowerShell\nGet-Module | Select-Object ModuleType, Version, Name\n\nModuleType Version        Name\n---------- -------        ----\n    Binary 1.0.0.0        Microsoft.PowerShell.LocalAccounts\n  Manifest 3.1.0.0        Microsoft.PowerShell.Management\n  Manifest 3.1.0.0        Microsoft.PowerShell.Utility\n```\n\nThis demonstrates why the Get-LoacalUser command must be called in a 64-bit environment as templated above by using the [sysnative folder](http://www.samlogic.net/articles/sysnative-folder-64-bit-windows.htm)."
  },
  {
    "name": "Windows - 64-Bit MultiLine Command | v1.0 JCCG",
    "type": "windows",
    "script": "```\n## Enter your command within the @' '@\n## Use single quotes ' not double quotes \" for all variables \n## Example multi-line command below\n\n$64BitCommand = @'\n$Hello = 'Howdy'\n$World = 'World'\nWrite-Host \"Well $Hello $World\"\n'@\n\n#------ Do not modify below this line ---------------\n& (Join-Path ($PSHOME -replace 'syswow64', 'sysnative') powershell.exe) -Command \"& {$64BitCommand}\"\n```",
    "link": "https://git.io/jccg-windows-64-bitmultilinecommand",
    "description": "A template to use to execute a multiline PowerShell command in the 64-bit environment. By default, all JumpCloud PowerShell commands are executed in the 32-bit PowerShell environment. Some commands are only available for execution in the 64-bit environment. \n\nTo determine if a command is 32 or 64-bit discovery can be done using the command Get-Command to find the module that a command is loaded in and then checking for that module in a 32-bit session.\n\nThe command Get-LocalUser is only available in the 64-bit environment.\n\nWe can see this by using the Get-Command function and passing in the Get-LocalUser command.\n\nExample \n```PowerShell\nGet-Command Get-LocalUser\n\nCommandType     Name                                               Version    Source\n-----------     ----                                               -------    ------\nCmdlet          Get-LocalUser                                      1.0.0.0    Microsoft.PowerShell.LocalAccounts\n\n```\nThe Get-LocalUser command shows the source of the Get-LocalUser command is the **Microsoft.PowerShell.LocalAccounts** module.\n\nWhen running Get-Module in the 32-bit environment, the output reveals that this module is not loaded and therefore any of the commands within the module are not accessible.\n\nExample from **32-bit shell:**\n```PowerShell\nGet-Module | Select-Object ModuleType, Version, Name\n\nModuleType Version Name\n---------- ------- ----\n  Manifest 3.1.0.0 Microsoft.PowerShell.Management\n  Manifest 3.1.0.0 Microsoft.PowerShell.Utility\n\n```\n\nWhen running the Get-Module command in the 64-bit environment we can see the **Microsoft.PowerShell.LocalAccounts**. \n\nExample from **64-bit shell:**\n```PowerShell\nGet-Module | Select-Object ModuleType, Version, Name\n\nModuleType Version        Name\n---------- -------        ----\n    Binary 1.0.0.0        Microsoft.PowerShell.LocalAccounts\n  Manifest 3.1.0.0        Microsoft.PowerShell.Management\n  Manifest 3.1.0.0        Microsoft.PowerShell.Utility\n```\n\nThis demonstrates why the Get-LoacalUser command must be called in a 64-bit environment as templated above by using the [sysnative folder](http://www.samlogic.net/articles/sysnative-folder-64-bit-windows.htm)."
  },
  {
    "name": "Windows - AppX Removal Startup Script | v1.0 JCCG",
    "type": "windows",
    "script": "```\n$Ps1FileName = 'AppXRemoval_Win10.ps1'\n\n$Ps1ScriptBody = @\"\n# Apps to remove\n`$appname = @(\n'*Microsoft.BingFinance*'\n'*Microsoft.SkypeApp*'\n'*Twitter*'\n'*Microsoft.3DBuilder*'\n'*king.com.CandyCrushSodaSaga*'\n'*Microsoft.BingNews*'\n'*Microsoft.WindowsMaps*'\n'*Microsoft.BingSports*'\n'*Microsoft.Office.OneNote*'\n'*Microsoft.MicrosoftSolitaireCollection*'\n'*Microsoft.WindowsAlarms*'\n'*Microsoft.BingWeather*'\n'*Microsoft.XboxApp*'\n)\n# Removes the above apps\nForEach(`$app in `$appname){\n    Get-AppxPackage -Name `$app | Remove-AppxPackage -ErrorAction SilentlyContinue\n}\n\n# Deletes the .bat and the .ps1  \nRemove-Item -Path \"`$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\startup\\LogOn.bat\"  -Force\nRemove-Item -Path \"`$env:USERPROFILE\\AppData\\local\\AppXRemoval_Win10.ps1\"  -Force\n\"@\n\n$BatBody = @\" \n@echo off\nstart Powershell.exe -executionpolicy remotesigned -windowstyle hidden -File  %userprofile%\\AppData\\Local\\AppXRemoval_Win10.ps1 /min\n\"@\n\n# Gets all of our users excluding Public user\n$users = Get-ChildItem -Path \"C:\\Users\" | ? {$_.Name -NE 'Public'} \n\n# Add files in all users /local and /Startup folder\nforeach($user in $users){\n\nNew-Item -Path \"C:\\Users\\$($user.name)\\AppData\\local\" -Name $Ps1FileName  -ItemType \"file\" -Value $Ps1ScriptBody \n\nNew-Item -Path \"C:\\Users\\$($user.name)\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\" -Name \"LogOn.bat\" -ItemType \"file\" -Value $BatBody\n\n}\n```",
    "link": "https://git.io/jccg-windows-appxremovalstartupscript",
    "description": "AppX applications are installed per user on a Windows machine. This command creates a .ps1 script and .bat file within each users profile where the payload of the .ps1 script uninstalls the listed AppX packages. Admins can add or remove AppX apps for the script to uninstall by modifying the $appname array.\n\nFind more info on removing AppX pacakages [here](https://www.pdq.com/blog/remove-appx-packages/#)"
  },
  {
    "name": "Windows - Change Lock Screen & Desktop Background | v1.0 JCCG",
    "type": "windows",
    "script": "```\n# Replace these variable sources with actual values:\n$LockScreenSource = 'C:\\pathToImages\\lockImage.jpg'\n$BackgroundSource = 'C:\\pathToImages\\backgroundImage.jpg'\n\nFunction Update-LockAndBackgroundScreen{\n    Param(\n            [Parameter(Mandatory=$false,Position=0)]\n            [ValidateNotNullOrEmpty()]\n            [string]$LockScreenSource,\n            [Parameter(Mandatory=$false,Position=1)]\n            [ValidateNotNullOrEmpty()]\n            [string]$BackgroundSource\n    )\n    Begin {\n        $ErrorActionPreference = \"Stop\"\n        $RegKeyPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PersonalizationCSP\"\n        $DesktopPath = \"DesktopImagePath\"\n        $DesktopStatus = \"DesktopImageStatus\"\n        $DesktopUrl = \"DesktopImageUrl\"\n        $LockScreenPath = \"LockScreenImagePath\"\n        $LockScreenStatus = \"LockScreenImageStatus\"\n        $LockScreenUrl = \"LockScreenImageUrl\"\n        $StatusValue = \"1\"\n        $DesktopImageValue = \"C:\\Windows\\System32\\Desktop.jpg\"\n        $LockScreenImageValue = \"C:\\Windows\\System32\\LockScreen.jpg\"\n    }\n    process{\n        if (!$LockScreenSource -and !$BackgroundSource)\n        {\n            Write-Host \"Either LockScreenSource or BackgroundSource must has a value.\"\n        }\n        else\n        {\n            if(!(Test-Path $RegKeyPath)) {\n                Write-Host \"Creating registry path $($RegKeyPath).\"\n                New-Item -Path $RegKeyPath -Force | Out-Null\n            }\n            if ($LockScreenSource) {\n                Write-Host \"Copy Lock Screen image from $($LockScreenSource) to $($LockScreenImageValue).\"\n                Copy-Item $LockScreenSource $LockScreenImageValue -Force\n                Write-Host \"Creating registry entries for Lock Screen\"\n                New-ItemProperty -Path $RegKeyPath -Name $LockScreenStatus -Value $StatusValue -PropertyType DWORD -Force | Out-Null\n                New-ItemProperty -Path $RegKeyPath -Name $LockScreenPath -Value $LockScreenImageValue -PropertyType STRING -Force | Out-Null\n                New-ItemProperty -Path $RegKeyPath -Name $LockScreenUrl -Value $LockScreenImageValue -PropertyType STRING -Force | Out-Null\n            }\n            if ($BackgroundSource) {\n                Write-Host \"Copy Desktop Background image from $($BackgroundSource) to $($DesktopImageValue).\"\n                Copy-Item $BackgroundSource $DesktopImageValue -Force\n                Write-Host \"Creating registry entries for Desktop Background\"\n                New-ItemProperty -Path $RegKeyPath -Name $DesktopStatus -Value $StatusValue -PropertyType DWORD -Force | Out-Null\n                New-ItemProperty -Path $RegKeyPath -Name $DesktopPath -Value $DesktopImageValue -PropertyType STRING -Force | Out-Null\n                New-ItemProperty -Path $RegKeyPath -Name $DesktopUrl -Value $DesktopImageValue -PropertyType STRING -Force | Out-Null\n            }\n            rundll32.exe user32.dll, UpdatePerUserSystemParameters\n        }\n    }\n}\n\n\nUpdate-LockAndBackgroundScreen -LockScreenSource $LockScreenSource -BackgroundSource $BackgroundSource\n```",
    "link": "https://git.io/Jsq9K",
    "description": "Change Lock Screen and Desktop Background in Windows 10 Pro. This script allows you to change logon screen and desktop background in Windows 10 Professional using GPO startup script. The Update-LockAndBackgroundScreen function takes two parameter sources, LockScreenSource & BackgroundSource. One or both parameters may be used to update the lock and desktop background. This script was modified from author: Juan Granados and originally posted at: https://gallery.technet.microsoft.com/scriptcenter/Change-Lock-Screen-and-245b63a0#content\n\nThis command can be used in conjunction with files uploaded directly to JumpCloud. Both the lock screen and desktop background images can be uploaded to systems as long as the file destination folder exists on the target system. In the example below the target system contained an 'images' directory in C:\\ prior to running the command.\n\n![wallpaper image](../Files/wallpaperImage.png)"
  },
  {
    "name": "Windows - Check if BitLocker is enabled | v1.0 JCCG",
    "type": "windows",
    "script": "```\nC:\\Windows\\Sysnative\\manage-bde.exe -status c:\n```",
    "link": "https://git.io/jccg-windows-checkifbitlockerisenabled",
    "description": "This command will check if BitLocker is enabled for the C drive"
  },
  {
    "name": "Windows - Disable Local User | v1.0 JCCG",
    "type": "windows",
    "script": "```\n################################################################################\n# This script will disable the *matched* username patterns in the usersToMatch\n# list variable. For Example:\n# Users on the system: administrator, steve, it-staff\n# $usersToMatch = @(\"admin\", \"it\")\n# both the administrator and it-staff would be disabled\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# Test how this command will run by setting the disable variable to false. When\n# set to false the script will identify users to disable and print out a list\n# without disabling the accounts\n################################################################################\n\n# Settings, set $true or $false\n$disable = $true\n\n# Enter user(s) patterns you want to match against (user admin bobsAccount)\n$usersToMatch = @(\"admin\", \"it\")\n\n# Do not modify below this line\n################################################################################\n\n$regexPattern=\"\"\n$last = [int]($usersToMatch.Length) - 1\nforeach ($user in $usersToMatch) {\n    Write-Host $user\n    if ($user -eq $usersToMatch[$last]){\n        $regexpattern += \"$($user)[^\\s]*\"\n    }\n    else{\n        $regexpattern += \"$($user)[^\\s]*|\"\n    }\n}\nWrite-Host \"Searching System for the following users: $usersToMatch\"\nWrite-Host \"Regex Pattern: $regexPattern\"\n\n$localUsers = Get-LocalUser\n$foundUsers = @()\nforeach ($username in $localUsers.name)\n{\n    if ($username -match $regexPattern)\n    {\n        # Set Selected Username Variable\n        write-host \"Matched $username user found\"\n        $foundUsers += $username\n    }\n}\n\nWrite-Host \"The Following users will be disabled: $foundUsers\"\n$loggedInUsers=query user\nforeach ($username in $foundUsers){\n    if ($disable){\n        if ($loggedInUsers -match $username) {\n            Write-Host \"Logging $username out of system\"\n            $session = quser | Where-Object { $_ -match $username }\n            ## Parse the session IDs from the output\n            $sessionIds = ($session -split ' +')[2]\n            Write-Host \"Found $sessionIds for $username on system.\"\n            ## Loop through each session ID and pass each to the logoff command\n            $sessionIds | ForEach-Object {\n                Write-Host \"Logging off session id [$($_)]...\"\n                logoff $_\n            }\n        }\n        Disable-LocalUser -Name $username\n    }\n}\n```",
    "link": "https://git.io/JnXGZ",
    "description": "This command will disable the local users that match the regex pattern supplied in the 'usersToMatch' list variable. If for example, a system contains the following users:\n\nSteve, Administrator, IT-Admin\n\nAnd the $usersToMatch variable is set to (\"admin\", \"it\"), both the 'Administrator' and 'IT-Admin' Account would be disabled. The Regex pattern searches usernames for partial matches.\n\nRun this script with disable=false to test what accounts would be disabled before running disable=true."
  },
  {
    "name": "Windows - Enable Task Scheduler History  | v1.0 JCCG",
    "type": "windows",
    "script": "```\n## Enables the windows event log for the task scheduler\n## Equivalent to checking the box \"Enable All Task History\" within task scheduler\n\n$TaskScheduler = 'Microsoft-Windows-TaskScheduler/Operational'\n$TaskSchedulerLog = New-Object System.Diagnostics.Eventing.Reader.EventLogConfiguration $TaskScheduler\n$TaskSchedulerLog.IsEnabled = $true\n$TaskSchedulerLog.SaveChanges()\n```",
    "link": "https://git.io/jccg-Windows-EnableTaskSchedulerHistory",
    "description": ""
  },
  {
    "name": "Windows - Exclude JCAgent from Windows Defender | v1.0 JCCG",
    "type": "windows",
    "script": "```\n$64BitCommand = \"Add-MpPreference -ExclusionPath 'C:\\Program Files (x86)\\JumpCloud\\jumpcloud-agent.exe'\"\n\n& (Join-Path ($PSHOME -replace 'syswow64', 'sysnative') powershell.exe) -Command \"& {$64BitCommand}\"\n```",
    "link": "",
    "description": "This command will remove the jumpcloud-agent.exe from Windows Defender scheduled and real-time scanning.\n\nThe command Add-MpPreference is only available in the 64-bit environment and the JumpCloud agent operates in the 32-bit environment which is why sysnative is used.\n\n### *Import This Command*\n\nTo import this command into your JumpCloud tenant run the below command using the [JumpCloud PowerShell Module](https://github.com/TheJumpCloud/support/wiki/Installing-the-JumpCloud-PowerShell-Module)\n\n```\nImport-JCCommand -URL 'https://git.io/jccg-windows-excludejcagentfromwindowsdefender'\n```"
  },
  {
    "name": "Windows - Get Installed PowerShell Version | v1.0 JCCG",
    "type": "windows",
    "script": "```\n$PSVersionTable\n```",
    "link": "https://git.io/jccg-Windows-GetInstalledPowerShellversion",
    "description": "The $PSVersionTable variable was first introduced in PowerShell version 2.0. The $PSVersionTable lists the version of PowerShell installed (\u201cPSVersion\u201d) and related components."
  },
  {
    "name": "Windows - Get JCagent.log | v1.0 JCCG",
    "type": "windows",
    "script": "```\nGet-content -Path 'C:\\Windows\\Temp\\jcagent.log'\n```",
    "link": "https://git.io/jccg-Windows-GetJCagent.log",
    "description": "Returns the jcagent.log from a Windows system. If the jcagent.log is larger than 1 MB the most recend 1 MB of data from the log will be returned."
  },
  {
    "name": "Windows - Get Logged In User | v1.0 JCCG",
    "type": "windows",
    "script": "```\nGet-WMIObject -class Win32_ComputerSystem | select-object -expandproperty username\n```",
    "link": "https://git.io/jccg-windows-getloggedinuser",
    "description": "Get current logged in user"
  },
  {
    "name": "Windows - Get OS Name and Version | v1.0 JCCG",
    "type": "windows",
    "script": "```\n$sys = (systeminfo /fo csv | ConvertFrom-Csv)\nreturn \"HostName: \" + ($sys.'Host Name') + \"`n\" + \"OS Name: \" + ($sys.'OS Name') + \"`n\" + \"OS Version: \" +($sys.'OS Version')\n```",
    "link": "https://git.io/jccg-windows-getosnameandversion",
    "description": "Returns the hostname, OS Name, and OS Version including build number of a Windows host."
  },
  {
    "name": "Windows - Get Service Account Logon Attempts | v1.0 JCCG",
    "type": "windows",
    "script": "```\n## Enter the date range to search on the lines below\n\n$StartTime = '11/05/2020 08:00:00'\n$EndTime = '11/05/2020 08:20:00'\n$EventIdFilter = ('4624', '4625')\n\n#------ Do not modify below this line ---------------\n\n$Events = Get-WinEvent -FilterHashtable @{ LogName = 'Security'; Id = $EventIdFilter; StartTime = $StartTime; EndTime = $EndTime; } | Where-Object { $_.Message | Select-String -Pattern:('(Logon Type:)(.*?)(5)') } | Sort-Object CreatedTimestamp\n$Events | ForEach-Object {\n    [PSCustomObject]@{\n        Type          = Switch ($_.Id) { '4624' { 'Login Success' } '4625' { 'Login Failure' } }\n        MachineName   = $_.MachineName\n        TimeCreated   = $_.TimeCreated\n        ElevatedToken = ($_.Message | Select-String -Pattern:('(Elevated Token:)(.*?)(\\n)')).Matches.Value.Replace('Elevated Token:', '').Trim()\n        AccountName   = ($_.Message | Select-String -AllMatches -Pattern:('(Account Name:)(.*?)(\\n)')).Matches.Value[1].Replace('Account Name:', '').Trim()\n        AccountDomain   = ($_.Message | Select-String -AllMatches -Pattern:('(Account Domain:)(.*?)(\\n)')).Matches.Value[1].Replace('Account Domain:', '').Trim()\n        ProcessName   = ($_.Message | Select-String -Pattern:('(Process Name:)(.*?)(\\n)')).Matches.Value.Replace('Process Name:', '').Trim()\n    }\n}\n```",
    "link": "https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Get%20Service%20Account%20Logon%20Attempts.md",
    "description": "Running this command will return events generated for when the Logon Title is **SERVICE** when a logon session is created or if an account logon attempt failed when the account was already locked out.\n\nThe command returns:\n```\nType          : Login Success\nMachineName   : My-Windows-PC\nTimeCreated   : 11/5/2020 08:01:55\nElevatedToken : Yes\nAccountName   : SYSTEM\nAccountDomain : NT AUTHORITY\nProcessName   : C:\\Windows\\System32\\services.exe\n\nType          : Login Success\nMachineName   : My-Windows-PC\nTimeCreated   : 11/5/2020 08:14:59\nElevatedToken : Yes\nAccountName   : SYSTEM\nAccountDomain : NT AUTHORITY\nProcessName   : C:\\Windows\\System32\\services.exe\n```\n\nFor more details about these event records see:\n* https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-4624\n* https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-4625"
  },
  {
    "name": "Windows - Get Windows Cached Credentials | v1.0 JCCG",
    "type": "windows",
    "script": "```\nfunction Test-ServiceForUserAccount {\n    param (\n        $StartName\n    )\n\n    if (-not $StartName) {\n        $false\n        return\n    }\n\n    $AccountName = $StartName.Trim().ToLower()\n\n    if (-not $AccountName) {\n        $false\n        return\n    }\n    if ($AccountName -eq 'localsystem') {\n        $false\n        return\n    }\n    if ($AccountName.StartsWith('nt authority\\')) {\n        $false\n        return\n    }\n\n    $true\n}\n\nfunction Write-ServiceInfos {\n    param (\n        [Parameter(ValueFromPipeline)]\n        [object[]]\n        $ServiceInfos\n    )\n\n    BEGIN {}\n\n    PROCESS {\n        foreach ($ServiceInfo in $ServiceInfos) {\n            Write-Output('')\n            Write-Output('    Name: ' + $ServiceInfo.Name)\n            Write-Output('    PathName: ' + $ServiceInfo.PathName)\n            Write-Output('    StartMode: ' + $ServiceInfo.StartMode)\n            Write-Output('    State: ' + $ServiceInfo.State)\n            Write-Output('    ProcessId: ' + $ServiceInfo.ProcessId)\n            Write-Output('    StartName: ' + $ServiceInfo.StartName)\n        }\n    }\n    END {}\n}\n\nfunction Test-TaskForUserAccount {\n    param (\n        $Principal\n    )\n\n    if (($Principal.LogonType -eq 'Password') -or ($Principal.LogonType -eq 'InteractiveOrPassword')) {\n\n        if (!($Principal.userid) -or ($Principal.userid -eq \"SYSTEM\") -or ($Principal.userid -eq \"LOCAL SERVICE\") -or ($Principal.userid -eq \"NETWORK SERVICE\")) {\n            $false\n            return\n        }\n\n        $true\n        return\n\n    }\n\n    $false\n}\n\nfunction Write-TaskInfos {\n    param (\n        [Parameter(ValueFromPipeline)]\n        [object[]]\n        $TaskInfos\n    )\n\n    BEGIN {}\n\n    PROCESS {\n        foreach ($TaskInfo in $TaskInfos) {\n            Write-Output('')\n            Write-Output('    TaskName: ' + $TaskInfo.TaskName)\n            Write-Output('    UserId: ' + $TaskInfo.Principal.UserId)\n            Write-Output('    LogonType: ' + $TaskInfo.Principal.LogonType)\n            Write-Output('    Execute: ' + [System.IO.Path]::GetFileName([System.Environment]::ExpandEnvironmentVariables($TaskInfo.Actions.Execute).Trim('\"')))\n            Write-Output('    Arguments: ' + [System.Environment]::ExpandEnvironmentVariables($TaskInfo.Actions.Arguments))\n        }\n    }\n    END {}\n}\n\nWrite-Output('Services that run in a user account context:')\nGet-WmiObject Win32_Service | Where { Test-ServiceForUserAccount($_.startname) } | Write-ServiceInfos\n\nWrite-Output('')\nWrite-Output('Scheduled tasks that run in a user account context:')\nGet-ScheduledTask | Where { Test-TaskForUserAccount($_.Principal) } | Write-TaskInfos\n\n& cmdkey.exe /list\n```",
    "link": "https://git.io/JO6RR",
    "description": "Executes a script to help identify Windows services, scheduled tasks, or third-party applications that use stored credentials and may potentially cause lockouts if the credentials get stale, usually after password changes."
  },
  {
    "name": "Windows - Get Windows Defender Settings | v1.0 JCCG",
    "type": "windows",
    "script": "```\n$64BitCommand = \"Get-MpPreference\"\n\n& (Join-Path ($PSHOME -replace 'syswow64', 'sysnative') powershell.exe) -Command \"& {$64BitCommand}\"\n```",
    "link": "",
    "description": "This command will return the Window Defender Exclusion settings\n\nThe command Get-MpPreference is only available in the 64-bit environment and the JumpCloud agent operates in the 32-bit environment which is why sysnative is used.\n\n### *Import This Command*\n\nTo import this command into your JumpCloud tenant run the below command using the [JumpCloud PowerShell Module](https://github.com/TheJumpCloud/support/wiki/Installing-the-JumpCloud-PowerShell-Module)\n\n```\nImport-JCCommand -URL 'https://git.io/jccg-windows-getwindowsdefendersettings'\n```"
  },
  {
    "name": "Windows - Install CrowdStrike Falcon Agent | v1.0 JCCG",
    "type": "windows",
    "script": "```\n$CID=\"ENTER CID WITH CHECKSUM VALUE HERE\"\n$installerURL=\"ENTER URL TO FALCON AGENT INSTALLER HERE\"\n\n############### Do Not Edit Below This Line ###############\n\n$installerTempLocation=\"C:\\Windows\\Temp\\CSFalconAgentInstaller.exe\"\n\nif (Get-Service \"CSFalconService\" -ErrorAction SilentlyContinue) {\n    Write-Host \"Falcon Agent already installed, nothing to do.\"\n    exit 0\n}\nWrite-Host \"Falcon Agent not installed.\"\n\nWrite-Host \"Downloading Falcon Agent installer now.\"\ntry {\n    Invoke-WebRequest -Uri $installerURL -OutFile $installerTempLocation\n}\ncatch {\n    Write-Error \"Unable to download Falcon Agent installer.\"\n    exit 1\n}\nWrite-Host \"Finished downloading Falcon Agent installer.\"\n\nWrite-Host \"Installing Falcon Agent now, this may take a few minutes.\"\ntry {\n    $args = @(\"/install\",\"/quiet\",\"/norestart\",\"CID=$CID\") \n    $installerProcess = Start-Process -FilePath $installerTempLocation -Wait -PassThru -ArgumentList $args\n}\ncatch {\n    Write-Error \"Failed to run Falcon Agent installer.\"\n    exit 1\n}\nWrite-Host \"Falcon Agent installer returned $($installerProcess.ExitCode).\"\n\nexit $installerProcess.ExitCode\n\n```",
    "link": "",
    "description": "This command will download and install the CrowdStrike Falcon Agent to the device if it isn't already installed.\n\nIn order to use this command:\n1. Download the CrowdStrike Falcon Agent installer and host it at a URL that your devices can access.\n2. Edit the first two lines of the script to include your Customer ID (with checksum value) and the URL where you are hosting the installer.\n3. Extend the command timeout to a value that makes sense in your environment.  The suggested command timeout for an environment with average network speeds on devices with average computing power is 10 minutes.  Note that the command may timeout with a 124 error code in the command result window if not extended, but the script will continue to run.\n4. It is recommended to set the Launch Event for the command to \u201cRun As Repeating\u201d with an interval of one hour.\n\n### *Import This Command*\n\nTo import this command into your JumpCloud tenant run the below command using the [JumpCloud PowerShell Module](https://github.com/TheJumpCloud/support/wiki/Installing-the-JumpCloud-PowerShell-Module)\n\n```\nImport-JCCommand -URL 'https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Install%20CrowdStrike%20Falcon%20Agent.md'\n```"
  },
  {
    "name": "Windows - List All Users | v1.0 JCCG",
    "type": "windows",
    "script": "```\n$UserAccounts = Get-WmiObject -Class Win32_UserAccount -Filter {LocalAccount = \"True\"} | select Name, Disabled \n\nWrite-Output $UserAccounts\n```",
    "link": "https://git.io/jccg-Windows-ListAllUsers",
    "description": "Lists all user accounts on a Windows system and shows if the account is enabled or disabled"
  },
  {
    "name": "Windows - Patch Zoom NTLM Vulnerability | v1.0 JCCG",
    "type": "windows",
    "script": "```\n$registryPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0\"\n$Name = \"RestrictSendingNTLMTraffic\"\n$value = 2\nNew-ItemProperty -Path $registryPath -Name $Name -value $value -PropertyType \"DWord\"\n```",
    "link": "https://git.io/JfeyX",
    "description": "Changes the NTLM Access to restrict sending NTLM traffic for a Windows machine. This patches the [security vulnerability with Zoom](https://www.bleepingcomputer.com/news/security/zoom-lets-attackers-steal-windows-credentials-run-programs-via-unc-links/)"
  },
  {
    "name": "Windows - Prompt Expiring Users To Update Their Password | v1.0 JCCG",
    "type": "windows",
    "script": "```\n## Populate below variable before running command\n$JCAPIKEY = '' \n\n## alertDaysThreshold set to '7' by default.\n## Users whose passwords will expire in 7 days or less will receive a prompt to update.\n## Update the value of the variable AlertDaysThreshold to modify the threshold.\n\n$AlertDaysThreshold = 7\n\n## Message Specific Variables\n\n$MessageBoxStyle = 4 # Look inside the Invoke-BroadcastMessage function for options.\n$MessageTitle = 'JumpCloud Password About To Expire' # Text to display in the message box title.\n$MessageBody = 'Your password will expire in {0} days. Click \"Yes\" to send a JumpCloud password reset link to your email.' # Text to display in the message box body.\n$TimeOutSec = 60 # How long you want the message box to display to the user.\n\n#------- Do not modify below this line ------\nFunction Invoke-BroadcastMessage\n{\n    [CmdletBinding(DefaultParameterSetName = 'Default')]\n    Param(\n        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true, Position = 0)][ValidateNotNullOrEmpty()][int]$SessionId,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 1)][ValidateRange(1, 6)][int]$MessageBoxStyle = 4,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 2)][ValidateNotNullOrEmpty()][string]$MessageTitle,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 3)][ValidateNotNullOrEmpty()][string]$MessageBody,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 4)][scriptblock]$ConfirmationAction,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 5)][int]$TimeOutSec = 60\n    )\n    # Message Box Style Options:\n    # 1 - Ok, Cancel\n    # 2 - Abort, Retry, Ignore\n    # 3 - Yes, No, Cancel\n    # 4 - Yes, No\n    # 5 - Retry, Cancel\n    # 6 - Cancel, Try Again, Continue\n    try\n    {\n        # Import classes\n        $WTSOpenSig = @\"\n[DllImport(\"wtsapi32.dll\", SetLastError=true)]\npublic static extern IntPtr WTSOpenServer(string pServerName);\n\"@\n        $WTSSendMessageSig = @\"\n[DllImport(\"wtsapi32.dll\", SetLastError = true)]\npublic static extern bool WTSSendMessage(\nIntPtr hServer,\n[MarshalAs(UnmanagedType.I4)] int SessionId,\nString pTitle,\n[MarshalAs(UnmanagedType.U4)] int TitleLength,\nString pMessage,\n[MarshalAs(UnmanagedType.U4)] int MessageLength,\n[MarshalAs(UnmanagedType.U4)] int Style,\n[MarshalAs(UnmanagedType.U4)] int Timeout,\n[MarshalAs(UnmanagedType.U4)] out int pResponse,\nbool bWait);\n\"@\n        $WTSOpen = Add-Type -MemberDefinition:($WTSOpenSig) -Name:('PSWTSOpenServer') -Namespace:('GetLoggedOnUsers') -PassThru\n        $WTSMessage = Add-Type -MemberDefinition:($WTSSendMessageSig) -Name:('PSWTSSendMessage') -Namespace:('GetLoggedOnUsers') -PassThru\n        # Define target machine\n        $Server = $WTSOpen::WTSOpenServer('LocalHost')\n        # Define misc variables\n        $ComputerName = $Env:ComputerName\n        $Response = ''\n        # Prompt user for message\n        $WTSMessage::WTSSendMessage($Server, $SessionId, $MessageTitle, $MessageTitle.Length, $MessageBody, $MessageBody.Length, $MessageBoxStyle, $TimeOutSec, [ref]$Response, $true) \n        $ResponseMessage = Switch ($Response)\n        {\n            1 {'Ok'}\n            2 {'Cancel'}\n            3 {'Abort'}\n            4 {'Retry'}\n            5 {'Ignore'}\n            6 {'Yes'}\n            7 {'No'}\n            10 {'Try Again'}\n            11 {'Continue'}\n            32001 {'Function returned without waiting for a response'}\n            32000 {'User did not respond within the timeout period'}\n            Default {'Unknown Response Value'}\n        }\n        If ($Response -in @(1, 6, 11))\n        {\n            If (-not([string]::IsNullOrEmpty($ConfirmationAction)))\n            {\n                Write-Verbose (\"Running command: $ConfirmationAction\")\n                Invoke-Command -ScriptBlock:($ConfirmationAction)\n            }\n        }\n        $Responses = [PSCustomObject]@{\n            'ComputerName'    = $ComputerName;\n            'SessionId'       = $SessionId;\n            'ResponseId'      = $Response;\n            'ResponseMessage' = $ResponseMessage;\n        }\n        Return $Responses\n    }\n    Catch\n    {\n        $Exception = $_.Exception\n        $Message = $Exception.Message\n        While ($Exception.InnerException)\n        {\n            $Exception = $Exception.InnerException\n            $Message += \"`n\" + $Exception.Message\n        }\n        Write-Error ($_.FullyQualifiedErrorId.ToString() + \"`n\" + $_.InvocationInfo.PositionMessage + \"`n\" + $Message)\n    }\n}\n\nFunction Invoke-PasswordResetNotification\n{\n    [CmdletBinding(DefaultParameterSetName = 'Default')]\n    Param(\n        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true, Position = 0)][ValidateNotNullOrEmpty()][string]$JCAPIKEY,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 1)][ValidateRange(1, 6)][int]$MessageBoxStyle = 4,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 2)][ValidateNotNullOrEmpty()][string]$MessageTitle,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 3)][ValidateNotNullOrEmpty()][string]$MessageBody,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 4)][int]$TimeOutSec = 60,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 5)][int]$AlertDaysThreshold = 7\n    )\n    Try\n    {\n        #Set JC headers\n        Write-Verbose 'Populating API headers'\n        $hdrs = @{\n            'Content-Type' = 'application/json'\n            'Accept'       = 'application/json'\n            'X-API-KEY'    = $JCAPIKEY\n        }\n        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n        # Get list of users on machine\n        $ActiveUsers = (quser) -Replace ('^>', '') -Replace ('\\s{2,}', ',') | ConvertFrom-Csv\n        # ForEach user\n        If ($ActiveUsers)\n        {\n            ForEach ($ActiveUser In $ActiveUsers)\n            {\n                $UserName = $ActiveUser.UserName\n                $SessionId = $ActiveUser.ID\n                $UserState = $ActiveUser.State\n                If ($UserState -eq 'Active')\n                {\n                    # Get user info\n                    $SystemUser_URL = 'https://console.jumpcloud.com/api/systemusers?fields=username email password_expiration_date&search[fields]=username&search[searchTerm]=' + $UserName\n                    $SystemUser = Invoke-RestMethod -Method:('GET') -Headers:($hdrs) -Uri:($SystemUser_URL)\n                    $SystemUser = $SystemUser.results | Where-Object {$_.username -eq $UserName}\n                    If ($SystemUser)\n                    {\n                        $Id = $SystemUser._id\n                        $UserName = $SystemUser.UserName\n                        $email = $SystemUser.email\n                        $password_expiration_date = $SystemUser.password_expiration_date\n                        #Convert dates to ToUniversalTime\n                        $TodaysDate = (Get-Date).ToUniversalTime()\n                        if ([string]::IsNullOrEmpty($password_expiration_date)) \n                        {\n                            Write-output ('user: \"' + $UserName + '\" is set to never expire.')\n                        }\n                        else\n                        {\n                            $password_expiration_date_Universal = Get-Date -Date:($password_expiration_date)\n                            # Get days till users password expires\n                            $TimeSpan = New-TimeSpan -Start:($TodaysDate) -End:($password_expiration_date_Universal)\n                            $DaysUntilPasswordExpire = [math]::ceiling($TimeSpan.TotalDays)\n                            # If days until password expires is less than the alert threshold\n                            If ($DaysUntilPasswordExpire -le $AlertDaysThreshold)\n                            {\n                                # Build confirmation action body\n                                $ConfirmationAction = {\n                                    $JsonBody = '{\"isSelectAll\":false,\"models\":[{\"_id\":\"' + $Id + '\"}]}'\n                                    $PasswordReset_URL = 'https://console.jumpcloud.com/api/systemusers/reactivate'\n                                    $PasswordReset = Invoke-RestMethod -Method:('POST') -Headers:($hdrs) -Uri:($PasswordReset_URL) -Body:($JsonBody)\n                                }\n                                $Response = Invoke-BroadcastMessage -SessionId:($SessionId) -MessageBoxStyle:($MessageBoxStyle) -MessageTitle:($MessageTitle) -MessageBody:($MessageBody -f $DaysUntilPasswordExpire) -ConfirmationAction:($ConfirmationAction) -TimeOutSec:($TimeOutSec)\n                                Return $Response | Where-Object {$_.ComputerName} | Select-Object ComputerName, SessionId, ResponseId, ResponseMessage, @{Name = 'UserName'; Expression = {$UserName}}, @{Name = 'password_expiration_date'; Expression = {$password_expiration_date}}\n                            }\n                            else\n                            {\n                                Write-Output (\"No Active JumpCloud users with expiring passwords found. See details of found users below:\")\n                                Return [PSCustomObject]@{\n                                    'UserName'                 = $UserName\n                                    'password_expiration_date' = $password_expiration_date\n                                    'DaysUntilPasswordExpires' = $DaysUntilPasswordExpire\n                                    'Notification Triggered'   = 'False'\n                                }\n                            }\n                        }\n                    }\n                    Else\n                    {\n                        Write-Warning ('Unable to find user: \"' + $UserName + '\". Active user \"' + $UserName +  '\" is not a JumpCloud user')\n                    }\n                }\n                else\n                {\n                    Write-Error ('Cannot read the state of the active user: \"' + $UserState + '\" Is not a valid state')\n                }\n            }\n        }\n        Else\n        {\n            Write-Output (\"No active users found on system\")\n        }\n    }\n    Catch\n    {\n        $Exception = $_.Exception\n        $Message = $Exception.Message\n        While ($Exception.InnerException)\n        {\n            $Exception = $Exception.InnerException\n            $Message += \"`n\" + $Exception.Message\n        }\n        Write-Error ($_.FullyQualifiedErrorId.ToString() + \"`n\" + $_.InvocationInfo.PositionMessage + \"`n\" + $Message)\n    }\n}\n\nInvoke-PasswordResetNotification -JCAPIKEY:($JCAPIKEY) -MessageBoxStyle:($MessageBoxStyle) -MessageTitle:($MessageTitle) -MessageBody:($MessageBody) -TimeOutSec:($TimeOutSec) -AlertDaysThreshold:($AlertDaysThreshold)\n```",
    "link": "https://git.io/fhFUU",
    "description": "1. Runs \"quser\" command to get a list of all active sessions on the machine. \n2. For each user with an active session query the users password expiration date. \n3. If it is determined that the users password will expire within the alert days threshold then a notification is displayed to the user asking them to reset their password.   \n4. If the user selects \"Yes\" then the action will trigger a password reset email to be sent to their inbox. If the user selects \"No\" then no action will occur. \n5. The output will contain the users response to the message box in the ResponseMessage field.\n\nRequired Variables:\n* $JCAPIKEY - This must be populated with your your API key.\n* By default AlertDaysThreshold is set to 7 days.\n\n![Windows_PasswordExpiration_Notification](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/Windows_PasswordExpiration_Notification.png?raw=true)"
  },
  {
    "name": "Windows - Windows - Prompt Users To Update Password With Expiration Date Logic | v1.0 JCCG",
    "type": "windows",
    "script": "```\n# Populate below variable before running command\n$JCAPIKEY = ''\n# Message Specific Variables\n$MessageBoxStyle = 4 # Look inside the Invoke-BroadcastMessage function for options.\n$MessageTitle = 'Update Your JumpCloud Password Immediately' # Text to display in the message box title.\n$MessageBody = 'Please update your JumpCloud password immediately. Click \"Yes\" to send a JumpCloud password reset link to your email.' # Text to display in the message box body.\n$TimeOutSec = 60 # How long you want the message box to display to the user.\n\n#------- Do not modify below this line ------\nFunction Invoke-BroadcastMessage\n{\n    [CmdletBinding(DefaultParameterSetName = 'Default')]\n    Param(\n        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true, Position = 0)][ValidateNotNullOrEmpty()][int]$SessionId,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 1)][ValidateRange(1, 6)][int]$MessageBoxStyle = 4,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 2)][ValidateNotNullOrEmpty()][string]$MessageTitle,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 3)][ValidateNotNullOrEmpty()][string]$MessageBody,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 4)][scriptblock]$ConfirmationAction,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 5)][int]$TimeOutSec = 60\n    )\n    # Message Box Style Options:\n    # 1 - Ok, Cancel\n    # 2 - Abort, Retry, Ignore\n    # 3 - Yes, No, Cancel\n    # 4 - Yes, No\n    # 5 - Retry, Cancel\n    # 6 - Cancel, Try Again, Continue\n    try\n    {\n        # Import classes\n        $WTSOpenSig = @\"\n[DllImport(\"wtsapi32.dll\", SetLastError=true)]\npublic static extern IntPtr WTSOpenServer(string pServerName);\n\"@\n        $WTSSendMessageSig = @\"\n[DllImport(\"wtsapi32.dll\", SetLastError = true)]\npublic static extern bool WTSSendMessage(\nIntPtr hServer,\n[MarshalAs(UnmanagedType.I4)] int SessionId,\nString pTitle,\n[MarshalAs(UnmanagedType.U4)] int TitleLength,\nString pMessage,\n[MarshalAs(UnmanagedType.U4)] int MessageLength,\n[MarshalAs(UnmanagedType.U4)] int Style,\n[MarshalAs(UnmanagedType.U4)] int Timeout,\n[MarshalAs(UnmanagedType.U4)] out int pResponse,\nbool bWait);\n\"@\n        $WTSOpen = Add-Type -MemberDefinition:($WTSOpenSig) -Name:('PSWTSOpenServer') -Namespace:('GetLoggedOnUsers') -PassThru\n        $WTSMessage = Add-Type -MemberDefinition:($WTSSendMessageSig) -Name:('PSWTSSendMessage') -Namespace:('GetLoggedOnUsers') -PassThru\n        # Define target machine\n        $Server = $WTSOpen::WTSOpenServer('LocalHost')\n        # Define misc variables\n        $ComputerName = $Env:ComputerName\n        $Response = ''\n        # Prompt user for message\n        $WTSMessage::WTSSendMessage($Server, $SessionId, $MessageTitle, $MessageTitle.Length, $MessageBody, $MessageBody.Length, $MessageBoxStyle, $TimeOutSec, [ref]$Response, $true) \n        $ResponseMessage = Switch ($Response)\n        {\n            1 {'Ok'}\n            2 {'Cancel'}\n            3 {'Abort'}\n            4 {'Retry'}\n            5 {'Ignore'}\n            6 {'Yes'}\n            7 {'No'}\n            10 {'Try Again'}\n            11 {'Continue'}\n            32001 {'Function returned without waiting for a response'}\n            32000 {'User did not respond within the timeout period'}\n            Default {'Unknown Response Value'}\n        }\n        If ($Response -in @(1, 6, 11))\n        {\n            If (-not([string]::IsNullOrEmpty($ConfirmationAction)))\n            {\n                Write-Verbose (\"Running command: $ConfirmationAction\")\n                Invoke-Command -ScriptBlock:($ConfirmationAction)\n            }\n        }\n        $Responses = [PSCustomObject]@{\n            'ComputerName'    = $ComputerName;\n            'SessionId'       = $SessionId;\n            'ResponseId'      = $Response;\n            'ResponseMessage' = $ResponseMessage;\n        }\n        Return $Responses\n    }\n    Catch\n    {\n        $Exception = $_.Exception\n        $Message = $Exception.Message\n        While ($Exception.InnerException)\n        {\n            $Exception = $Exception.InnerException\n            $Message += \"`n\" + $Exception.Message\n        }\n        Write-Error ($_.FullyQualifiedErrorId.ToString() + \"`n\" + $_.InvocationInfo.PositionMessage + \"`n\" + $Message)\n    }\n}\n\nFunction Invoke-PasswordResetNotification\n{\n    [CmdletBinding(DefaultParameterSetName = 'Default')]\n    Param(\n        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true, Position = 0)][ValidateNotNullOrEmpty()][string]$JCAPIKEY,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 1)][ValidateRange(1, 6)][int]$MessageBoxStyle = 4,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 2)][ValidateNotNullOrEmpty()][string]$MessageTitle,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 3)][ValidateNotNullOrEmpty()][string]$MessageBody,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 4)][int]$TimeOutSec = 60\n    )\n    Try\n    {\n        #Set JC headers\n        Write-Verbose 'Populating API headers'\n        $hdrs = @{\n            'Content-Type' = 'application/json'\n            'Accept'       = 'application/json'\n            'X-API-KEY'    = $JCAPIKEY\n        }\n        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n        # Get list of users on machine\n        $ActiveUsers = (quser) -Replace ('^>', '') -Replace ('\\s{2,}', ',') | ConvertFrom-Csv\n        # ForEach user\n        If ($ActiveUsers)\n        {\n            ForEach ($ActiveUser In $ActiveUsers)\n            {\n                $UserName = $ActiveUser.UserName\n                $SessionId = $ActiveUser.ID\n                $UserState = $ActiveUser.State\n                If ($UserState -eq 'Active')\n                {\n                    # Get organization info\n                    $Settings_Url = 'https://console.jumpcloud.com/api/settings'\n                    $Organizations_Url = 'https://console.jumpcloud.com/api/organizations/{0}'\n                    $Settings = Invoke-RestMethod -Method:('GET') -Headers:($hdrs) -Uri:($Settings_Url)\n                    $Organizations = Invoke-RestMethod -Method:('GET') -Headers:($hdrs) -Uri:($Organizations_Url -f $Settings.ORG_ID)\n                    # Get user info\n                    $SystemUser_URL = 'https://console.jumpcloud.com/api/systemusers?fields=username email password_expiration_date&search[fields]=username&search[searchTerm]=' + $UserName\n                    $SystemUser = Invoke-RestMethod -Method:('GET') -Headers:($hdrs) -Uri:($SystemUser_URL)\n                    $SystemUser = $SystemUser.results | Where-Object {$_.username -eq $UserName}\n                    If ($SystemUser)\n                    {\n                        $Id = $SystemUser._id\n                        $UserName = $SystemUser.UserName\n                        $email = $SystemUser.email\n                        $password_expiration_date = $SystemUser.password_expiration_date\n                        \n                        If ($password_expiration_date)\n                        {\n                            $passwordExpirationInDays = $Organizations.settings.passwordPolicy.passwordExpirationInDays\n                            $password_set_date = (Get-Date($password_expiration_date)).AddDays(-$passwordExpirationInDays)\n                            #Convert dates to ToUniversalTime\n                            $TodaysDate = (Get-Date).ToUniversalTime()\n                            $password_expiration_date_Universal = Get-Date -Date:($password_expiration_date)\n                            # Get days till users password expires\n                            $TimeSpan = New-TimeSpan -Start:($TodaysDate) -End:($password_expiration_date_Universal)\n                            $DaysUntilPasswordExpire = [math]::ceiling($TimeSpan.TotalDays)\n                            # If DaysUntilPasswordExpire is less than passwordExpirationInDays\n                            If ($DaysUntilPasswordExpire -lt $passwordExpirationInDays)\n                            {\n                                # Build confirmation action body\n                                $ConfirmationAction = {\n                                    $JsonBody = '{\"isSelectAll\":false,\"models\":[{\"_id\":\"' + $Id + '\"}]}'\n                                    $PasswordReset_URL = 'https://console.jumpcloud.com/api/systemusers/reactivate'\n                                    $PasswordReset = Invoke-RestMethod -Method:('POST') -Headers:($hdrs) -Uri:($PasswordReset_URL) -Body:($JsonBody)\n                                }\n                                $Response = Invoke-BroadcastMessage -SessionId:($SessionId) -MessageBoxStyle:($MessageBoxStyle) -MessageTitle:($MessageTitle) -MessageBody:($MessageBody -f $DaysUntilPasswordExpire) -ConfirmationAction:($ConfirmationAction) -TimeOutSec:($TimeOutSec)\n                                Return $Response | Where-Object {$_.ComputerName} | Select-Object ComputerName, SessionId, ResponseId, ResponseMessage, `\n                                @{Name = 'UserName'; Expression = {$UserName}}, `\n                                @{Name = 'password_expiration_date'; Expression = {$password_expiration_date}}, `\n                                @{Name = 'DaysUntilPasswordExpiration'; Expression = {$DaysUntilPasswordExpire}}, `\n                                @{Name = 'PasswordUpdate'; Expression = {'Pending'}}\n                            }\n                            else\n                            {\n                                Write-Output (\"No Active JumpCloud users with expiring passwords found. See details of found users below:\")\n                                Return [PSCustomObject]@{\n                                    'UserName'                 = $UserName\n                                    'password_expiration_date' = $password_expiration_date\n                                    'DaysUntilPasswordExpires' = $DaysUntilPasswordExpire\n                                    'PasswordUpdate'           = 'Complete'\n                                    'Notification Triggered'   = 'False'\n                                }\n                            }\n                        }\n                        else\n                        {\n                            Write-Warning ('Unable to find expiration date for user: \"' + $UserName + '\" or user password does not expire.')\n                        }\n                    }\n                    Else\n                    {\n                        Write-Warning ('Unable to find user: \"' + $UserName + '\". Active user \"' + $UserName +  '\" is not a JumpCloud user')\n                    }\n                }\n                else\n                {\n                    Write-Error ('Cannot read the state of the active user: \"' + $UserState + '\" Is not a valid state')\n                }\n            } \n        }\n        Else\n        {\n            Write-Output (\"No active users found on system\")\n        }\n    }\n    Catch\n    {\n        $Exception = $_.Exception\n        $Message = $Exception.Message\n        While ($Exception.InnerException)\n        {\n            $Exception = $Exception.InnerException\n            $Message += \"`n\" + $Exception.Message\n        }\n        Write-Error ($_.FullyQualifiedErrorId.ToString() + \"`n\" + $_.InvocationInfo.PositionMessage + \"`n\" + $Message)\n    }\n}\n\nInvoke-PasswordResetNotification -JCAPIKEY:($JCAPIKEY) -MessageBoxStyle:($MessageBoxStyle) -MessageTitle:($MessageTitle) -MessageBody:($MessageBody) -TimeOutSec:($TimeOutSec)\n```",
    "link": "https://git.io/fhpfr",
    "description": "1. Runs \"quser\" command to get a list of all active sessions on the machine.\n   Note: This script expects an English return of \"Active\" for the above command in order to complete successfully. If OS isn't default English, the script may return an error.\n2. Query the organizations JumpCloud password expiration policy.\n3. For each user with an active session query the users password expiration date.\n4. If the signed in user has not reset their password on the day the command is run then a notification is sent to the user. **This logic allows the command to be set to run as a repeating on a set of target systems and will only re-prompt users who do not take action and update their passwords.**\n5. If the user selects \"Yes\" then the action will trigger a password reset email to be sent to their inbox. If the user selects \"No\" then no action will occur.\n6. The output will contain the users response to the message box in the ResponseMessage field.\n\n\nRequired Variables:\n* JCAPIKEY - This must be populated with your API key.\n* Password aging must be enabled in the JumpCloud Organization settings.\n\n![Windows_PasswordUpdate_Notification](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/Windows_PasswordUpdate_Notification.png?raw=true)"
  },
  {
    "name": "Windows - Prompt Users To Update Password | v1.0 JCCG",
    "type": "windows",
    "script": "```\n# Populate below variable before running command\n$JCAPIKEY = ''\n# Message Specific Variables\n$MessageBoxStyle = 4 # Look inside the Invoke-BroadcastMessage function for options.\n$MessageTitle = 'Update Your JumpCloud Password Immediately' # Text to display in the message box title.\n$MessageBody = 'Please update your JumpCloud password immediately. Click \"Yes\" to send a JumpCloud password reset link to your email.' # Text to display in the message box body.\n$TimeOutSec = 60 # How long you want the message box to display to the user.\n\n#------- Do not modify below this line ------\nFunction Invoke-BroadcastMessage\n{\n    [CmdletBinding(DefaultParameterSetName = 'Default')]\n    Param(\n        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true, Position = 0)][ValidateNotNullOrEmpty()][int]$SessionId,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 1)][ValidateRange(1, 6)][int]$MessageBoxStyle = 4,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 2)][ValidateNotNullOrEmpty()][string]$MessageTitle,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 3)][ValidateNotNullOrEmpty()][string]$MessageBody,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 4)][scriptblock]$ConfirmationAction,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 5)][int]$TimeOutSec = 60\n    )\n    # Message Box Style Options:\n    # 1 - Ok, Cancel\n    # 2 - Abort, Retry, Ignore\n    # 3 - Yes, No, Cancel\n    # 4 - Yes, No\n    # 5 - Retry, Cancel\n    # 6 - Cancel, Try Again, Continue\n    try\n    {\n        # Import classes\n        $WTSOpenSig = @\"\n[DllImport(\"wtsapi32.dll\", SetLastError=true)]\npublic static extern IntPtr WTSOpenServer(string pServerName);\n\"@\n        $WTSSendMessageSig = @\"\n[DllImport(\"wtsapi32.dll\", SetLastError = true)]\npublic static extern bool WTSSendMessage(\nIntPtr hServer,\n[MarshalAs(UnmanagedType.I4)] int SessionId,\nString pTitle,\n[MarshalAs(UnmanagedType.U4)] int TitleLength,\nString pMessage,\n[MarshalAs(UnmanagedType.U4)] int MessageLength,\n[MarshalAs(UnmanagedType.U4)] int Style,\n[MarshalAs(UnmanagedType.U4)] int Timeout,\n[MarshalAs(UnmanagedType.U4)] out int pResponse,\nbool bWait);\n\"@\n        $WTSOpen = Add-Type -MemberDefinition:($WTSOpenSig) -Name:('PSWTSOpenServer') -Namespace:('GetLoggedOnUsers') -PassThru\n        $WTSMessage = Add-Type -MemberDefinition:($WTSSendMessageSig) -Name:('PSWTSSendMessage') -Namespace:('GetLoggedOnUsers') -PassThru\n        # Define target machine\n        $Server = $WTSOpen::WTSOpenServer('LocalHost')\n        # Define misc variables\n        $ComputerName = $Env:ComputerName\n        $Response = ''\n        # Prompt user for message\n        $WTSMessage::WTSSendMessage($Server, $SessionId, $MessageTitle, $MessageTitle.Length, $MessageBody, $MessageBody.Length, $MessageBoxStyle, $TimeOutSec, [ref]$Response, $true) \n        $ResponseMessage = Switch ($Response)\n        {\n            1 {'Ok'}\n            2 {'Cancel'}\n            3 {'Abort'}\n            4 {'Retry'}\n            5 {'Ignore'}\n            6 {'Yes'}\n            7 {'No'}\n            10 {'Try Again'}\n            11 {'Continue'}\n            32001 {'Function returned without waiting for a response'}\n            32000 {'User did not respond within the timeout period'}\n            Default {'Unknown Response Value'}\n        }\n        If ($Response -in @(1, 6, 11))\n        {\n            If (-not([string]::IsNullOrEmpty($ConfirmationAction)))\n            {\n                Write-Verbose (\"Running command: $ConfirmationAction\")\n                Invoke-Command -ScriptBlock:($ConfirmationAction)\n            }\n        }\n        $Responses = [PSCustomObject]@{\n            'ComputerName'    = $ComputerName;\n            'SessionId'       = $SessionId;\n            'ResponseId'      = $Response;\n            'ResponseMessage' = $ResponseMessage;\n        }\n        Return $Responses\n    }\n    Catch\n    {\n        $Exception = $_.Exception\n        $Message = $Exception.Message\n        While ($Exception.InnerException)\n        {\n            $Exception = $Exception.InnerException\n            $Message += \"`n\" + $Exception.Message\n        }\n        Write-Error ($_.FullyQualifiedErrorId.ToString() + \"`n\" + $_.InvocationInfo.PositionMessage + \"`n\" + $Message)\n    }\n}\n\nFunction Invoke-PasswordResetNotification\n{\n    [CmdletBinding(DefaultParameterSetName = 'Default')]\n    Param(\n        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true, Position = 0)][ValidateNotNullOrEmpty()][string]$JCAPIKEY,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 1)][ValidateRange(1, 6)][int]$MessageBoxStyle = 4,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 2)][ValidateNotNullOrEmpty()][string]$MessageTitle,\n        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $true, Position = 3)][ValidateNotNullOrEmpty()][string]$MessageBody,\n        [Parameter(Mandatory = $false, ValueFromPipelineByPropertyName = $true, Position = 4)][int]$TimeOutSec = 60\n    )\n    Try\n    {\n        #Set JC headers\n        Write-Verbose 'Populating API headers'\n        $hdrs = @{\n            'Content-Type' = 'application/json'\n            'Accept'       = 'application/json'\n            'X-API-KEY'    = $JCAPIKEY\n        }\n        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n        # Get list of users on machine\n        $ActiveUsers = (quser) -Replace ('^>', '') -Replace ('\\s{2,}', ',') | ConvertFrom-Csv\n        # ForEach user\n        If ($ActiveUsers)\n        {\n            ForEach ($ActiveUser In $ActiveUsers)\n            {\n                $UserName = $ActiveUser.UserName\n                $SessionId = $ActiveUser.ID\n                $UserState = $ActiveUser.State\n                If ($UserState -eq 'Active')\n                {\n                \n                    # Get user info\n                    $SystemUser_URL = 'https://console.jumpcloud.com/api/systemusers?fields=username email password_expiration_date&search[fields]=username&search[searchTerm]=' + $UserName\n                    $SystemUser = Invoke-RestMethod -Method:('GET') -Headers:($hdrs) -Uri:($SystemUser_URL)\n                    $SystemUser = $SystemUser.results | Where-Object {$_.username -eq $UserName}\n                    If ($SystemUser)\n                    {\n                        $Id = $SystemUser._id\n                        $UserName = $SystemUser.UserName\n                        $email = $SystemUser.email\n                        $password_expiration_date = $SystemUser.password_expiration_date\n                        $passwordExpirationInDays = $Organizations.settings.passwordPolicy.passwordExpirationInDays\n                        $password_set_date = (Get-Date($password_expiration_date)).AddDays(-$passwordExpirationInDays)\n\n                        #Convert dates to ToUniversalTime\n                        $TodaysDate = (Get-Date).ToUniversalTime()\n                        $password_expiration_date_Universal = Get-Date -Date:($password_expiration_date)\n                        # Get days till users password expires\n                        $TimeSpan = New-TimeSpan -Start:($TodaysDate) -End:($password_expiration_date_Universal)\n                        $DaysUntilPasswordExpire = [math]::ceiling($TimeSpan.TotalDays)\n\n                        # Build confirmation action body\n                        $ConfirmationAction = {\n                            $JsonBody = '{\"isSelectAll\":false,\"models\":[{\"_id\":\"' + $Id + '\"}]}'\n                            $PasswordReset_URL = 'https://console.jumpcloud.com/api/systemusers/reactivate'\n                            $PasswordReset = Invoke-RestMethod -Method:('POST') -Headers:($hdrs) -Uri:($PasswordReset_URL) -Body:($JsonBody)\n                        }\n                        $Response = Invoke-BroadcastMessage -SessionId:($SessionId) -MessageBoxStyle:($MessageBoxStyle) -MessageTitle:($MessageTitle) -MessageBody:($MessageBody -f $DaysUntilPasswordExpire) -ConfirmationAction:($ConfirmationAction) -TimeOutSec:($TimeOutSec)\n                        Return $Response | Where-Object {$_.ComputerName} | Select-Object ComputerName, SessionId, ResponseId, ResponseMessage, `\n                        @{Name = 'UserName'; Expression = {$UserName}}, `\n                        @{Name = 'password_expiration_date'; Expression = {$password_expiration_date}}, `\n                        @{Name = 'DaysUntilPasswordExpiration'; Expression = {$DaysUntilPasswordExpire}}\n\n                    }\n                    Else\n                    {\n                        Write-Warning ('Unable to find user: \"' + $UserName + '\". Active user \"' + $UserName +  '\" is not a JumpCloud user')\n                    }\n                }\n                else\n                {\n                    Write-Error ('Cannot read the state of the active user: \"' + $UserState + '\" Is not a valid state')\n                }\n            }\n        }\n        Else\n        {\n            Write-Output (\"No active users found on system\")\n        }\n    }\n    Catch\n    {\n        $Exception = $_.Exception\n        $Message = $Exception.Message\n        While ($Exception.InnerException)\n        {\n            $Exception = $Exception.InnerException\n            $Message += \"`n\" + $Exception.Message\n        }\n        Write-Error ($_.FullyQualifiedErrorId.ToString() + \"`n\" + $_.InvocationInfo.PositionMessage + \"`n\" + $Message)\n    }\n}\n\nInvoke-PasswordResetNotification -JCAPIKEY:($JCAPIKEY) -MessageBoxStyle:($MessageBoxStyle) -MessageTitle:($MessageTitle) -MessageBody:($MessageBody) -TimeOutSec:($TimeOutSec)\n```\n\n### Deprecation Note\n\nThis script is deprecated for:\n https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Windows%20Commands/Windows%20-%20Prompt%20Expiring%20Users%20To%20Update%20Password.md \n\nThis referenced script can be edited to prompt all users by adjusting the $AlertDaysThreshold variable.",
    "link": "https://git.io/fhpfX",
    "description": "1. Runs \"quser\" command to get a list of all active sessions on the machine.\n2. Sends a notification to the user asking them to reset their password. This command will prompt all users that are active, regardless if their passwords are expiring or not.\n3. If the user selects \"Yes\" then the action will trigger a password reset email to be sent to their inbox. If the user selects \"No\" then no action will occur.\n4. The output will contain the users response to the message box in the ResponseMessage field.\n\nRequired Variables:\n* JCAPIKEY - This must be populated with your API key.\n\n[![Windows_PasswordUpdate_Notification](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/Windows_PasswordExpiration_Notification.png?raw=true)\n](![Windows_PasswordUpdate_Notification](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/Windows_PasswordUpdate_Notification.png?raw=true))"
  },
  {
    "name": "Windows - Run As Signed In User Template | v1.1 JCCG",
    "type": "windows",
    "script": "```powershell\n# If PSModule RunAsUser is not installed, install it\nif ( -not (get-installedModule \"RunAsUser\" -ErrorAction SilentlyContinue)) {\n    install-module RunAsUser -force\n}\n\n$Command = {\n    #Powershell Command Goes Here.\n}\n\ninvoke-ascurrentuser -scriptblock $Command\n```",
    "link": "https://git.io/Jv5ea",
    "description": "This template can be modified to target a command to run as the signed in user context of a system. The Jumpcloud agent cmd runner executes as NTAuthority\\System and therefore can not interact with the signed in user session on a computer. This template and accompanying Powershell Module code from https://github.com/KelvinTegelaar/RunAsUser allows the Command block to be run as the signed in user session.\n\nBefore running this command the **$Command** block must be populated.\n\nAn example of this command is if  ```C:\\windows\\system32\\notepad.exe``` is placed in the command block and executed against a system that has a signed in user session. Notepad will launch and show up for the signed in user. This will also work if the session is locked but still signed in. It however can only work when there is one signed in session like on most workstation SKU's of Windows."
  },
  {
    "name": "Windows - Run Once Template - Remove System From Associated System Group | v1.0 JCCG",
    "type": "windows",
    "script": "```\n# Populate systemGroupID and JumpCloudAPIKey variables before running the command\n\n$systemGroupID=''\n$JumpCloudAPIKey=''\n\n#--------------------Enter command below this line--------------------\n\n\n#--------------------Do not modify below this line--------------------\n\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n\n$conf = Get-Content 'C:\\Program Files\\JumpCloud\\Plugins\\Contrib\\jcagent.conf'\n$conf -match \"systemKey`\":`\"(`\\w+)`\"\" | Out-Null\n$systemKey = $Matches[1]\n\n$Request = @{\n\n    Method    = \"Post\"\n    Uri       = \"https://console.jumpcloud.com/api/v2/systemgroups/$systemGroupID/members\"\n    Body      = @{op= \"remove\";type= \"system\";id= \"$systemKey\" } | ConvertTo-Json\n    Header    = @{'Content-Type' = 'application/json'; 'Accept' = 'application/json'; 'X-API-KEY' = \"$JumpCloudAPIKey\" }\n    UserAgent = 'JCCommand'\n}\n\ntry\n{\n    Invoke-RestMethod @Request\n    Write-Output \"JumpCloud system: ${systemKey} removed from system group $systemGroupID\"\n}\ncatch\n{\n    Write-Output \"Error:  $($_.ErrorDetails)\"\n}\n\n```",
    "link": "https://git.io/Jeul8",
    "description": "This template can be modified to satisfy use cases where admins wish to run a command once on a number of target systems and have the system automatically removed from the system group which associates the system with the command.\n\n*Directly associating JumpCloud systems to JumpCloud commands? [No problem refer to this template for removing systems from a JumpCloud command]()*\n\nBefore running this command the variables **systemGroupID=''** and **JumpCloudAPIKey** must be populated.\n\nTo find the systemGroupID for a JumpCloud system group navigate to the \"GROUPS\" section of the JumpCloud admin portal and select the system group to bring up the system group details. Within the URL of the selected command the systemGroupID will be the 24 character string between 'system/' and '/details'. The JumpCloud PowerShell command [Get-JCGroup](https://github.com/TheJumpCloud/support/wiki/Get-JCGroup) can also be used to find the systemGroupID. The systemGroupID is the 'id' value which will be displayed for each JumpCloud group when Get-JCGroup is called.\n\n![systemGroupID example](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/systemGroupID.png?raw=true)\n\nEnter the payload of the command under the line '#--------------------Enter command below this line--------------------'"
  },
  {
    "name": "Windows - Run Once Template - Remove System From Command | v1.0 JCCG",
    "type": "windows",
    "script": "```\n# Populate commandID and JumpCloudAPIKey variables before running the command\n\n$commandID=''\n$JumpCloudAPIKey=''\n\n#--------------------Enter command below this line--------------------\n\n\n#--------------------Do not modify below this line--------------------\n\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n\n$conf = Get-Content 'C:\\Program Files\\JumpCloud\\Plugins\\Contrib\\jcagent.conf'\n$conf -match \"systemKey`\":`\"(`\\w+)`\"\" | Out-Null\n$systemKey = $Matches[1]\n\n$Request = @{\n\n    Method    = \"Post\"\n    Uri       = \"https://console.jumpcloud.com/api/v2/commands/$commandID/associations\"\n    Body      = @{type = \"system\"; op = \"remove\"; id = $systemKey } | ConvertTo-Json\n    Header    = @{'Content-Type' = 'application/json'; 'Accept' = 'application/json'; 'X-API-KEY' = \"$JumpCloudAPIKey\" }\n    UserAgent = 'JCCommand'\n}\n\ntry\n{\n    Invoke-RestMethod @Request\n    Write-Output \"JumpCloud system: ${systemKey} removed from command target list\"\n}\ncatch\n{\n    Write-Output \"Error:  $($_.ErrorDetails)\"\n}\n\n```",
    "link": "https://git.io/JeulE",
    "description": "This template can be used to satisfy use cases where admins wish to run a command once on a number of target systems and have the system automatically removed from the commands system target list after the command is run.\n\n*Using a system group for associating systems with JumpCloud commands? [No problem refer to this template for removing systems from a JumpCloud command from an associated JumpCloud system group]().*\n\nBefore running this command the variables **commandID=''** and **JumpCloudAPIKey** must be populated.\n\n![commanID example](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/commandID.png?raw=true)\n\nTo find the commandID within the JumpCloud admin console select the command to expand the command details. Within the URL of the selected command the commandID will be the 24 character string between 'commands/' and '/details'. The JumpCloud PowerShell command [Get-JCCommand](https://github.com/TheJumpCloud/support/wiki/Get-JCCommand) can also be used to find the commandID which will reveal the commandID in the '_id' field.\n\nEnter the payload of the command under the line '#--------------------Enter command below this line--------------------'"
  },
  {
    "name": "Windows - Send Notification Message | JCCG v1.0",
    "type": "windows",
    "script": "```\n# Enter the notification message\n# Enter the message within the \"\" of $Notification=\"\"\n\n$Notification=\"\"\n\n# ------- Do not modify below this line ------\n\nInvoke-WmiMethod -Path Win32_Process -Name Create -ArgumentList \"msg * $Notification\"\n```",
    "link": "https://git.io/jccg-windows-sendnotificationmessage",
    "description": "Administrators that wish to send notification messages to the current logged in user of the target Windows machines can use this command. \n\nTo use this command enter the text to display through the notification in the $Notification=\"\" variable.\n\nExample: $Notification=\"Fire drill at 10 am on Monday\"\n\n![Example Notification](https://github.com/TheJumpCloud/support/blob/master/PowerShell/JumpCloud%20Commands%20Gallery/Files/Windows%20notification.png?raw=true)"
  },
  {
    "name": "Windows - Set Agent Log Level to Debug | v1.0 JCCG",
    "type": "Windows",
    "script": "```\n$loglevel = \"DEBUG\"\n#Find jcagent install path\n$configfiledefault = (Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\JumpCloud\\JumpCloud Agent\\ConfigFile\\').'(default)'\n$index = ($configfiledefault).IndexOf(\"Plugins\")\n$jcinstallpath = $configfiledefault.Substring(0,$index)\n#Remove loglevel.cache if exists\nRemove-Item $jcinstallpath'Loglevel.cache' -ea ig\n#add debug or trace to file\nNew-Item -Path $jcinstallpath -Name Loglevel.cache -ItemType \"file\" -Value $loglevel\n\n#Schedules JumpCloud Agent Restart\nif ( -not (Test-Path -path \"C:\\Windows\\Temp\\JC_ScheduledTasks\"))\n{\n    New-Item -Path \"C:\\Windows\\Temp\\JC_ScheduledTasks\" -ItemType directory\n}\n\n#Creates Agent restart script file\n$FileDate = (get-date -f yyyy-MM-dd-hh-mm)\n$FileName = \"JC_ScheduledWAgentRestart$FileDate.ps1\"\n$TaskName = \"JC_ScheduledWAgentRestart$FileDate\"\n$FilePath = \"C:\\Windows\\Temp\\JC_ScheduledTasks\\\"\n$FileContents = @\"\n    Stop-Service jumpcloud-agent -force\n    Copy-Item -Path \"C:\\Windows\\Temp\\jcagent.log\" -Destination \"C:\\Windows\\Temp\\jcagent_$FileDate.log\"\n    Start-Sleep -Seconds 1\n    Start-Service jumpcloud-agent\n    SCHTASKS /Delete /tn \"$TaskName\" /F\n    #Remove-Item -LiteralPath `$MyInvocation.MyCommand.Path -Force\n\"@\nNew-Item -Path $FilePath -Name $FileName  -ItemType \"file\" -Value $FileContents\n\n#Schedules task to run in 60s\n$RunTime = (Get-Date).AddSeconds(60) | Get-Date -UFormat %R\nSCHTASKS /create /tn \"$TaskName\" /tr \"powershell.exe -noprofile -executionpolicy Unrestricted -file $FilePath$FileName\" /sc ONCE /st $RunTime /RU \"NT AUTHORITY\\SYSTEM\"\n```",
    "link": "https://git.io/JUUdy",
    "description": "This command will set the JumpCloud Agent Log Level to Debug. The Agent Log Level can also be set to Trace by changing the `$loglevel` variable from \"DEBUG\" to \"TRACE\". After the command is run, a scheduled task triggers a second script that sets restarts the JumpCloud Agent and removes the itself."
  },
  {
    "name": "Windows - Set Agent Log Level to Default | v1.0 JCCG",
    "type": "Windows",
    "script": "```\n#Find jcagent install path\n$configfiledefault = (Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\JumpCloud\\JumpCloud Agent\\ConfigFile\\').'(default)'\n$index = ($configfiledefault).IndexOf(\"Plugins\")\n$jcinstallpath = $configfiledefault.Substring(0,$index)\n#Remove loglevel.cache if exists\nRemove-Item $jcinstallpath'Loglevel.cache' -ea ig\n\n#Schedules JumpCloud Agent Restart\nif ( -not (Test-Path -path \"C:\\Windows\\Temp\\JC_ScheduledTasks\"))\n{\n    New-Item -Path \"C:\\Windows\\Temp\\JC_ScheduledTasks\" -ItemType directory\n}\n\n#Creates Agent restart script file\n$FileDate = (get-date -f yyyy-MM-dd-hh-mm)\n$FileName = \"JC_ScheduledWAgentRestart$FileDate.ps1\"\n$TaskName = \"JC_ScheduledWAgentRestart$FileDate\"\n$FilePath = \"C:\\Windows\\Temp\\JC_ScheduledTasks\\\"\n$FileContents = @\"\n    Stop-Service jumpcloud-agent -force\n    Copy-Item -Path \"C:\\Windows\\Temp\\jcagent.log\" -Destination \"C:\\Windows\\Temp\\jcagent_$FileDate.log\"\n    Start-Sleep -Seconds 1\n    Start-Service jumpcloud-agent\n    SCHTASKS /Delete /tn \"$TaskName\" /F\n    #Remove-Item -LiteralPath `$MyInvocation.MyCommand.Path -Force\n\"@\nNew-Item -Path $FilePath -Name $FileName  -ItemType \"file\" -Value $FileContents\n\n#Schedules task to run in 60s\n$RunTime = (Get-Date).AddSeconds(60) | Get-Date -UFormat %R\nSCHTASKS /create /tn \"$TaskName\" /tr \"powershell.exe -noprofile -executionpolicy Unrestricted -file $FilePath$FileName\" /sc ONCE /st $RunTime /RU \"NT AUTHORITY\\SYSTEM\"\n```",
    "link": "https://git.io/JUUdH",
    "description": "This command will set the JumpCloud Agent Log Level to Default. After the command is run, a scheduled task triggers a second script that sets restarts the JumpCloud Agent and removes the itself."
  },
  {
    "name": "Windows - Software Restriction Policy | v1.0 JCCG",
    "type": "windows",
    "script": "```\n$RestrictedDirectory = @(\"%UserProfile%\\Downloads\\\", \"C:\\Windows\\Temp\\\")\n$ExecutableTypes = @(\"ADE\",\"ADP\",\"BAS\",\"BAT\",\"CHM\",\"CMD\",\"COM\",\"CPL\",\"CRT\",\"EXE\",\"HLP\",\"HTA\",\"INF\",\"INS\",\"ISP\",\"LNK\",\"MDB\",\"MDE\",\"MSC\",\"MSI\",\"MSP\",\"MST\",\"OCX\",\"PCD\",\"PIF\",\"REG\",\"SCR\",\"SHS\",\"URL\",\"VB\",\"WSC\")\n\nif((Test-Path -LiteralPath \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\") -eq $true) {Remove-Item \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\" -Recurse};\nNew-Item \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\";\nNew-Item \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\";\nNew-Item \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\\0\";\nNew-Item \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\\0\\Paths\";\nNew-ItemProperty 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers' -Name 'authenticodeenabled' -Value 0 -PropertyType DWord;\nNew-ItemProperty 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers' -Name 'DefaultLevel' -Value 262144 -PropertyType DWord;\nNew-ItemProperty 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers' -Name 'TransparentEnabled' -Value 1 -PropertyType DWord;\nNew-ItemProperty 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers' -Name 'PolicyScope' -Value 0 -PropertyType DWord;\nNew-ItemProperty 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers' -Name 'ExecutableTypes' -Value $ExecutableTypes -PropertyType MultiString;\n\nforeach ($Directory in $RestrictedDirectory){\n    $pathguid = [guid]::newguid()\n    $newpathkey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\\0\\Paths\\{\" + $pathguid + \"}\"\n    if((Test-Path -LiteralPath $newpathkey) -ne $true) {New-Item $newpathkey};\n    New-ItemProperty -LiteralPath $newpathkey -Name 'SaferFlags' -Value 0 -PropertyType DWord;\n    New-ItemProperty -LiteralPath $newpathkey -Name 'ItemData' -Value $Directory -PropertyType ExpandString;\n}\n```",
    "link": "https://git.io/JvdPw",
    "description": "Adds a software restriction policy to windows. This policy will restrict the execution of any matching file type in the restricted directory."
  },
  {
    "name": "Windows - Start Quick Assist Session | v1.1 JCCG",
    "type": "windows",
    "script": "```\ninstall-module RunAsUser -force\n$Command = {\n\nC:\\Windows\\System32\\quickassist.exe\n\n}\n```",
    "link": "https://git.io/Jv5eg",
    "description": "Executes 'Windows 10 Quick Assist' application as the currently logged on user. The command will fail if no user is logged in."
  }
]